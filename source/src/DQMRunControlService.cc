  /// \file DQMRunControlService.cc
/*
 *
 * DQMRunControlService.cc source template automatically generated by a class generator
 * Creation date : mer. nov. 12 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMRunControlService.h"
#include "dqm4hep/DQMRunControl.h"
#include "dqm4hep/DQMRun.h"

namespace dqm4hep
{

DQMCurrentRunRpc::DQMCurrentRunRpc(char *rpcName, DQMRunControlService *pService) :
		DimRpc(rpcName, "I", "C"),
		m_pService(pService)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMCurrentRunRpc::rpcHandler()
{
	m_pService->handleCurrentRunRpc(this);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMRunControlService::DQMRunControlService() :
		m_currentRunNumber(-1),
		m_serviceState(STOPPED_STATE),
		m_pStartOfRunService(NULL),
		m_pEndOfRunService(NULL),
		m_pRunControl(NULL),
		m_pCurrentRunRpc(NULL),
		m_runControlName("DEFAULT"),
		m_dataStream(1024)
{
	m_pRunControl = new DQMRunControl();
}

//-------------------------------------------------------------------------------------------------

DQMRunControlService::~DQMRunControlService()
{
	if(isRunning())
	{
		if(RUNNING_STATE == m_pRunControl->getRunState())
			endCurrentRun();

		stop();
	}

	delete m_pRunControl;

	if(m_pRunBuffer)
		delete [] m_pRunBuffer;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::start()
{
	if(isRunning())
		return STATUS_CODE_ALREADY_INITIALIZED;

	std::string sorServiceName = "DQM4HEP/RunControl/" + m_runControlName + "/START_OF_RUN";
	std::string eorServiceName = "DQM4HEP/RunControl/" + m_runControlName + "/END_OF_RUN";
	std::string currentRunRpcName = "DQM4HEP/RunControl/" + m_runControlName + "/CURRENT_RUN";

	m_pStartOfRunService = new DimService(sorServiceName.c_str(), "C", (void*) m_dataStream.getBuffer(), m_dataStream.getBufferSize());
	m_pEndOfRunService   = new DimService(eorServiceName.c_str(), "C", (void*) m_dataStream.getBuffer(), m_dataStream.getBufferSize());
	m_pCurrentRunRpc = new DQMCurrentRunRpc( (char *) currentRunRpcName.c_str(), this);

	m_serviceState = RUNNING_STATE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::stop()
{
	if(!isRunning())
		return STATUS_CODE_NOT_INITIALIZED;

	delete m_pStartOfRunService;
	delete m_pEndOfRunService;

	m_pStartOfRunService = NULL;
	m_pEndOfRunService = NULL;

	m_serviceState = STOPPED_STATE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::pause()
{
	return stop();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::restart()
{
	if(isRunning())
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, stop());
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, start());

		return STATUS_CODE_SUCCESS;
	}
	else
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, start());

		return STATUS_CODE_SUCCESS;
	}
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::startNewRun(unsigned int runNumber, const std::string &description, const std::string &detectorName)
{
	if(!isRunning())
		return STATUS_CODE_NOT_INITIALIZED;

	if(RUNNING_STATE == getRunState())
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, endCurrentRun());

	m_currentRunNumber = runNumber;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->startNewRun(m_currentRunNumber, description, detectorName));

	m_dataStream.reset();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->getCurrentRun()->serialize(&m_dataStream));

	m_pStartOfRunService->updateService(m_dataStream.getBuffer(), m_dataStream.getBufferSize());
	m_dataStream.reset();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::startNewRun(DQMRun *pRun)
{
	if(!isRunning())
		return STATUS_CODE_NOT_INITIALIZED;

	if(RUNNING_STATE == getRunState())
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, endCurrentRun());

	m_currentRunNumber = pRun->getRunNumber();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->startNewRun(pRun));

	m_dataStream.reset();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->getCurrentRun()->serialize(&m_dataStream));

	m_pStartOfRunService->updateService(m_dataStream.getBuffer(), m_dataStream.getBufferSize());
	m_dataStream.reset();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::endCurrentRun()
{
	if(!isRunning())
		return STATUS_CODE_NOT_INITIALIZED;

	if(RUNNING_STATE != getRunState())
		return STATUS_CODE_SUCCESS;

	m_currentRunNumber = -1;

	m_pRunControl->getCurrentRun()->setEndTime(time(0));

	m_dataStream.reset();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->getCurrentRun()->serialize(&m_dataStream));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->endCurrentRun());

	m_pEndOfRunService->updateService(m_dataStream.getBuffer(), m_dataStream.getBufferSize());

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

int DQMRunControlService::getCurrentRunNumber() const
{
	return m_currentRunNumber;
}

//-------------------------------------------------------------------------------------------------

DQMState DQMRunControlService::getRunState() const
{
	return m_pRunControl->getRunState();
}

//-------------------------------------------------------------------------------------------------

bool DQMRunControlService::isRunning() const
{
	return (m_serviceState == RUNNING_STATE);
}

//-------------------------------------------------------------------------------------------------

DQMState DQMRunControlService::getState() const
{
	return m_serviceState;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::setRunControlName(const std::string &runControlName)
{
	if(isRunning())
		return STATUS_CODE_NOT_ALLOWED;

	m_runControlName = runControlName;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMRunControlService::getRunControlName() const
{
	return m_runControlName;
}

//-------------------------------------------------------------------------------------------------

DQMRun *DQMRunControlService::getCurrentRun() const
{
	return m_pRunControl->getCurrentRun();
}

//-------------------------------------------------------------------------------------------------

void DQMRunControlService::handleCurrentRunRpc(DimRpc *pRpc)
{
	if(!this->isRunning())
		return;

	std::cout << "Handling current run rpc !" << std::endl;

	try
	{
		// if running send the current run
		// else send back an empty run
		if(m_pRunControl->isRunning())
		{
			// stream
			m_dataStream.reset();
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->getCurrentRun()->serialize(&m_dataStream));

			// send back current run
			pRpc->setData( (void *) m_dataStream.getBuffer() , m_dataStream.getBufferSize() );

			// reset
			m_dataStream.reset();
		}
		else
		{
			DQMRun emptyRun;

			// stream
			m_dataStream.reset();
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, emptyRun.serialize(&m_dataStream));

			// send back empty run
			pRpc->setData( (void *) m_dataStream.getBuffer() , m_dataStream.getBufferSize() );

			// reset
			m_dataStream.reset();
		}
	}
	catch(StatusCodeException &exception)
	{
		std::cout << "Couldn't send back current run : " << exception.toString() << std::endl;
	}
}

} 

