  /// \file DQMRunControlService.cc
/*
 *
 * DQMRunControlService.cc source template automatically generated by a class generator
 * Creation date : mer. nov. 12 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMRunControlService.h"
#include "dqm4hep/DQMRunControl.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMLogging.h"

namespace dqm4hep
{

static const char DQMRunControlService_emptyBuffer [] = "EMPTY";

DQMCurrentRunRpc::DQMCurrentRunRpc(char *rpcName, DQMRunControlService *pService) :
		DimRpc(rpcName, "I", "C"),
		m_pService(pService)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMCurrentRunRpc::rpcHandler()
{
	m_pService->handleCurrentRunRpc(this);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMRunControlService::DQMRunControlService() :
		m_currentRunNumber(-1),
		m_serviceState(STOPPED_STATE),
		m_pStartOfRunService(NULL),
		m_pEndOfRunService(NULL),
		m_pRunControl(NULL),
		m_pCurrentRunRpc(NULL),
		m_runControlName("DEFAULT"),
		m_pOutBuffer(0)
{
	m_pRunControl = new DQMRunControl();
	m_pOutBuffer = new xdrstream::BufferDevice(1024);
}

//-------------------------------------------------------------------------------------------------

DQMRunControlService::~DQMRunControlService()
{
	if(this->isRunning())
	{
		if(RUNNING_STATE == m_pRunControl->getRunState())
			this->endCurrentRun();

		this->stop();
	}

	delete m_pRunControl;
	delete m_pOutBuffer;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::start()
{
	if(isRunning())
		return STATUS_CODE_ALREADY_INITIALIZED;

	std::string sorServiceName = "DQM4HEP/RunControl/" + m_runControlName + "/START_OF_RUN";
	std::string eorServiceName = "DQM4HEP/RunControl/" + m_runControlName + "/END_OF_RUN";
	std::string currentRunRpcName = "DQM4HEP/RunControl/" + m_runControlName + "/CURRENT_RUN";

	m_pStartOfRunService = new DimService(sorServiceName.c_str(), "C", (void*) DQMRunControlService_emptyBuffer, 5);
	m_pEndOfRunService   = new DimService(eorServiceName.c_str(), "C", (void*) DQMRunControlService_emptyBuffer, 5);
	m_pCurrentRunRpc = new DQMCurrentRunRpc( (char *) currentRunRpcName.c_str(), this);

	m_serviceState = RUNNING_STATE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::stop()
{
	if(!isRunning())
		return STATUS_CODE_NOT_INITIALIZED;

	delete m_pStartOfRunService;
	delete m_pEndOfRunService;

	m_pStartOfRunService = NULL;
	m_pEndOfRunService = NULL;

	m_serviceState = STOPPED_STATE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::pause()
{
	return stop();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::restart()
{
	if(isRunning())
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, stop());
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, start());

		return STATUS_CODE_SUCCESS;
	}
	else
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, start());

		return STATUS_CODE_SUCCESS;
	}
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::startNewRun(unsigned int runNumber, const std::string &description, const std::string &detectorName)
{
	if(!isRunning())
		return STATUS_CODE_NOT_INITIALIZED;

	if(RUNNING_STATE == getRunState())
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, endCurrentRun());

	m_currentRunNumber = runNumber;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->startNewRun(m_currentRunNumber, description, detectorName));

	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != m_pRunControl->getCurrentRun()->stream( xdrstream::XDR_WRITE_STREAM , m_pOutBuffer ) )
		return STATUS_CODE_FAILURE;

	m_pStartOfRunService->updateService( (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition());

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::startNewRun(DQMRun *pRun)
{
	if(!isRunning())
		return STATUS_CODE_NOT_INITIALIZED;

	if(RUNNING_STATE == getRunState())
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, endCurrentRun());

	m_currentRunNumber = pRun->getRunNumber();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->startNewRun(pRun));

	m_pOutBuffer->reset();
	if( xdrstream::XDR_SUCCESS != m_pRunControl->getCurrentRun()->stream( xdrstream::XDR_WRITE_STREAM , m_pOutBuffer ) )
		return STATUS_CODE_FAILURE;

	m_pStartOfRunService->updateService( (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition());

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::endCurrentRun()
{
	if(!isRunning())
		return STATUS_CODE_NOT_INITIALIZED;

	if(RUNNING_STATE != getRunState())
		return STATUS_CODE_SUCCESS;

	m_currentRunNumber = -1;
	m_pRunControl->getCurrentRun()->setEndTime(time(0));
	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != m_pRunControl->getCurrentRun()->stream( xdrstream::XDR_WRITE_STREAM , m_pOutBuffer ) )
		return STATUS_CODE_FAILURE;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRunControl->endCurrentRun());

	m_pEndOfRunService->updateService((void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition());

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

int DQMRunControlService::getCurrentRunNumber() const
{
	return m_currentRunNumber;
}

//-------------------------------------------------------------------------------------------------

DQMState DQMRunControlService::getRunState() const
{
	return m_pRunControl->getRunState();
}

//-------------------------------------------------------------------------------------------------

bool DQMRunControlService::isRunning() const
{
	return (m_serviceState == RUNNING_STATE);
}

//-------------------------------------------------------------------------------------------------

DQMState DQMRunControlService::getState() const
{
	return m_serviceState;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRunControlService::setRunControlName(const std::string &runControlName)
{
	if(isRunning())
		return STATUS_CODE_NOT_ALLOWED;

	m_runControlName = runControlName;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMRunControlService::getRunControlName() const
{
	return m_runControlName;
}

//-------------------------------------------------------------------------------------------------

DQMRun *DQMRunControlService::getCurrentRun() const
{
	return m_pRunControl->getCurrentRun();
}

//-------------------------------------------------------------------------------------------------

void DQMRunControlService::handleCurrentRunRpc(DimRpc *pRpc)
{
	if(!this->isRunning())
		return;

	try
	{
		// if running send the current run
		// else send back an empty run
		if(m_pRunControl->isRunning())
		{
			// stream
			m_pOutBuffer->reset();

			if( xdrstream::XDR_SUCCESS != m_pRunControl->getCurrentRun()->stream( xdrstream::XDR_WRITE_STREAM , m_pOutBuffer ) )
				throw StatusCodeException(STATUS_CODE_FAILURE);

			// send back current run
			pRpc->setData( (void *) m_pOutBuffer->getBuffer() , m_pOutBuffer->getPosition() );
		}
		else
		{
			DQMRun emptyRun;

			// stream
			m_pOutBuffer->reset();

			if( xdrstream::XDR_SUCCESS != emptyRun.stream( xdrstream::XDR_WRITE_STREAM , m_pOutBuffer ) )
				throw StatusCodeException(STATUS_CODE_FAILURE);

			// send back current run
			pRpc->setData( (void *) m_pOutBuffer->getBuffer() , m_pOutBuffer->getPosition() );
		}
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't send back current run : " << exception.toString() );
	}
}

} 

