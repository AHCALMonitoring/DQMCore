  /// \file DQMMonitorElement.cc
/*
 *
 * DQMMonitorElement.cc source template automatically generated by a class generator
 * Creation date : jeu. sept. 4 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Ete Remi
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMDataStream.h"

// -- root headers
#include "TObject.h"
#include "TNamed.h"
#include "TBufferFile.h"
#include "TH1.h"
#include "TH1F.h"
#include "TH1I.h"
#include "TH1S.h"
#include "TH1C.h"
#include "TH2.h"
#include "TH2F.h"
#include "TH2I.h"
#include "TH2S.h"
#include "TH2C.h"
#include "TProfile.h"
#include "TProfile2D.h"

templateClassImp(dqm4hep::TScalarObject)

namespace dqm4hep
{

//-------------------------------------------------------------------------------------------------

DQMMonitorElement::DQMMonitorElement(DQMMonitorElementType type,
		const std::string &name, const std::string &title,
		const std::string &moduleName) :
		m_type(type),
		m_name(name),
		m_title(title),
		m_moduleName(moduleName),
		m_description(""),
		m_drawOption(""),
		m_quality(NO_QUALITY),
		m_resetPolicy(END_OF_RUN_RESET_POLICY),
		m_runNumber(0),
		m_toPublish(true),
		m_pObject(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElement::DQMMonitorElement(TObject *pObject, DQMMonitorElementType type,
		const std::string &name, const std::string &title,
		const std::string &moduleName) :
		m_type(type),
		m_name(name),
		m_title(title),
		m_description(""),
		m_moduleName(moduleName),
		m_drawOption(""),
		m_quality(NO_QUALITY),
		m_resetPolicy(END_OF_RUN_RESET_POLICY),
		m_runNumber(0),
		m_toPublish(true),
		m_pObject(pObject)
{
	if(NULL == m_pObject)
		throw StatusCodeException(STATUS_CODE_INVALID_PARAMETER);
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElement::~DQMMonitorElement()
{
	if(NULL != m_pObject)
		delete m_pObject;

	m_qualityTestMap.clear();
	m_qualityTestResultMap.clear();
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getModuleName() const
{
	return m_moduleName;
}

//-------------------------------------------------------------------------------------------------

DQMQuality DQMMonitorElement::getQuality() const
{
	return m_quality;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setQuality(DQMQuality quality)
{
	m_quality = quality;
}

//-------------------------------------------------------------------------------------------------

DQMResetPolicy DQMMonitorElement::getResetPolicy() const
{
	return m_resetPolicy;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setResetPolicy(DQMResetPolicy policy)
{
	m_resetPolicy = policy;
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementType DQMMonitorElement::getType() const
{
	return m_type;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getName() const
{
	return m_name;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getTitle() const
{
	return m_title;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setTitle(const std::string &title)
{
	m_title = title;

	if(m_pObject)
	{
		TNamed *pNamed = dynamic_cast<TNamed*>(m_pObject);

		if(pNamed)
			pNamed->SetTitle(title.c_str());
	}
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getDescription() const
{
	return m_description;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setDescription(const std::string &description)
{
	m_description = description;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getDrawOption() const
{
	return m_drawOption;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setDrawOption(const std::string &drawOption)
{
	m_drawOption = drawOption;

	if(m_pObject)
		m_pObject->SetDrawOption(drawOption.c_str());
}

//-------------------------------------------------------------------------------------------------

unsigned int DQMMonitorElement::getRunNumber() const
{
	return m_runNumber;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setToPublish(bool toPublish)
{
	m_toPublish = toPublish;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElement::isToPublish() const
{
	return m_toPublish;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setRunNumber(unsigned int runNumber)
{
	m_runNumber = runNumber;
}

//-------------------------------------------------------------------------------------------------

TObject *DQMMonitorElement::getObject() const
{
	return m_pObject;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::reset()
{
	m_pObject->Clear();

	// special case for histograms
	TH1 *pHistogram = dynamic_cast<TH1 *>(m_pObject);

	if(NULL != pHistogram)
		pHistogram->Reset();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setFullPath(const std::string &fullPathName)
{
	m_fullPathName = fullPathName;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElement::isHistogram() const
{
	if(m_type >= INT_HISTOGRAM_1D_ELEMENT_TYPE && m_type <= PROFILE_2D_ELEMENT_TYPE)
		return true;

	return false;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElement::isScalar() const
{
	if(m_type >= INT_ELEMENT_TYPE && m_type <= STRING_ELEMENT_TYPE)
		return true;

	return false;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getFullPath() const
{
	return m_fullPathName;
}

//-------------------------------------------------------------------------------------------------

const DQMPath &DQMMonitorElement::getPath() const
{
	return m_path;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setPath(const DQMPath &path)
{
	m_path = path;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getCollectorName() const
{
	return m_collectorName;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setCollectorName(const std::string &collectorName)
{
	m_collectorName = collectorName;
}

//-------------------------------------------------------------------------------------------------

const DQMQualityTestResultMap &DQMMonitorElement::getQualityTestResults() const
{
	return m_qualityTestResultMap;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::serialize(DQMDataStream *const pDataStream) const
{
	dqm_int elementType = static_cast<dqm_int>(getType());
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(elementType));

	std::string elementName = getName();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(elementName));

	std::string elementTitle = getTitle();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(elementTitle));

	TObject *pObject = getObject();

	dqm_bool hasTObject = (NULL != pObject);
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(hasTObject));

	if(hasTObject)
	{
		if(elementType == INT_ELEMENT_TYPE)
		{
			dqm_int value = get<TScalarInt>()->Get();
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
		}
		else if(elementType == REAL_ELEMENT_TYPE)
		{
			dqm_float value = get<TScalarReal>()->Get();
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
		}
		else if(elementType == SHORT_ELEMENT_TYPE)
		{
			dqm_short value = get<TScalarShort>()->Get();
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
		}
		else if(elementType == STRING_ELEMENT_TYPE)
		{
			std::string value = get<TScalarString>()->Get();
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
		}
		else
		{
			// serialize
			TBufferFile bufferFile(TBuffer::kWrite);
			bufferFile.WriteObject(pObject);

			// get the buffer and length
			const dqm_char *pRawBuffer = bufferFile.Buffer();
			dqm_int bufferSize = bufferFile.BufferSize();

			// and write it
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(pRawBuffer, bufferSize));
		}
	}

	dqm_int elementQuality = static_cast<dqm_int>(getQuality());
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(elementQuality));

	std::string drawOption = getDrawOption();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(drawOption));

	// deprecated
	std::string fullPathName = getFullPath();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(fullPathName));

	std::string path = getPath().getPath();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(path));

	std::string collectorName = getCollectorName();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(collectorName));

	std::string moduleName = getModuleName();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(moduleName));

	std::string elementDescription = getDescription();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(elementDescription));

	dqm_int resetPolicy = static_cast<dqm_int>(getResetPolicy());
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(resetPolicy));

	dqm_uint runNumber = static_cast<dqm_uint>(getRunNumber());
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(runNumber));

	dqm_bool isToPublish = this->isToPublish();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(isToPublish));

	dqm_uint nQTestResults = m_qualityTestResultMap.size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nQTestResults));

	for(std::map<std::string, DQMQualityTestResult>::const_iterator iter = m_qualityTestResultMap.begin(),
			endIter = m_qualityTestResultMap.end() ; endIter != iter ; ++iter)
	{
		// write qtest name
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(iter->first));

		// write qtest result
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, iter->second.serialize(pDataStream));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::deserialize(DQMDataStream *const pDataStream)
{
	dqm_int elementType = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(elementType));

	std::string elementName;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(elementName));

	std::string elementTitle;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(elementTitle));

	dqm_bool hasTObject;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(hasTObject));

	TObject *pObject = NULL;

	if(hasTObject)
	{
		if(elementType == INT_ELEMENT_TYPE)
		{
			dqm_int value;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
			pObject = new TScalarInt(value);
		}
		else if(elementType == REAL_ELEMENT_TYPE)
		{
			dqm_float value;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
			pObject = new TScalarReal(value);
		}
		else if(elementType == SHORT_ELEMENT_TYPE)
		{
			dqm_short value;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
			pObject = new TScalarShort(value);
		}
		else if(elementType == STRING_ELEMENT_TYPE)
		{
			std::string value;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
			pObject = new TScalarString(value);
		}
		else
		{
			dqm_char *pBuffer = NULL;
			dqm_uint bufferSize = 0;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(pBuffer, bufferSize));

			TBufferFile bufferFile(TBuffer::kRead, bufferSize, pBuffer);
			pObject = bufferFile.ReadObject(0);
		}

		if(NULL == pObject)
			return STATUS_CODE_FAILURE;
	}

	dqm_int elementQuality = static_cast<dqm_int>(NO_QUALITY);
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(elementQuality));

	std::string drawOption;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(drawOption));

	// deprecated !
	std::string fullPathName;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(fullPathName));

	std::string path;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(path));

	std::string collectorName;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(collectorName));

	std::string moduleName;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(moduleName));

	std::string elementDescription;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(elementDescription));

	dqm_int resetPolicy = static_cast<dqm_int>(NO_RESET_POLICY);
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(resetPolicy));

	dqm_uint runNumber = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(runNumber));

	dqm_bool isToPublish = true;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(isToPublish));

	dqm_uint nQTestResults = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nQTestResults));

	for(unsigned int q=0 ; q<nQTestResults ; q++)
	{
		std::string qTestName;
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(qTestName));

		DQMQualityTestResult qTestResult;
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, qTestResult.deserialize(pDataStream));

		m_qualityTestResultMap[qTestName] = qTestResult;
	}

	if(0 != m_pObject)
	{
		delete m_pObject;
		m_pObject = 0;
	}

	m_pObject = pObject;

	if(m_pObject)
	{
		TNamed *pNamed = dynamic_cast<TNamed*>(m_pObject);

		if(pNamed)
			pNamed->SetName((fullPathName + "/" + elementName).c_str());
	}

	m_name = elementName;
	m_type = static_cast<DQMMonitorElementType>(elementType);
	m_moduleName = moduleName;

	this->setTitle(elementTitle);
	this->setQuality(static_cast<DQMQuality>(elementQuality));
	this->setDrawOption(drawOption);
	this->setFullPath(fullPathName); // deprecated
	this->setPath(DQMPath(path));
	this->setCollectorName(collectorName);
	this->setDescription(elementDescription);
	this->setResetPolicy(static_cast<DQMResetPolicy>(resetPolicy));
	this->setRunNumber(runNumber);
	this->setToPublish(isToPublish);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::runQualityTest(const std::string &qualityTestName)
{
	std::map<std::string, DQMQualityTest*>::iterator findIter = m_qualityTestMap.find(qualityTestName);

	if(findIter == m_qualityTestMap.end())
		return STATUS_CODE_NOT_FOUND;

	DQMQualityTest *pQualityTest = findIter->second;
	DQMQualityTestResult result;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->run(this, result));

	m_qualityTestResultMap[pQualityTest->getName()] = result;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::runQualityTests()
{
	for(std::map<std::string, DQMQualityTest*>::iterator iter = m_qualityTestMap.begin(), endIter = m_qualityTestMap.end() ;
			endIter != iter ; ++iter)
	{
		DQMQualityTest *pQualityTest = iter->second;
		DQMQualityTestResult result;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->run(this, result));

		m_qualityTestResultMap[pQualityTest->getName()] = result;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::addQualityTest(DQMQualityTest *pQualityTest)
{
	if(NULL == pQualityTest)
		return STATUS_CODE_INVALID_PTR;

	std::map<std::string, DQMQualityTest*>::iterator findIter = m_qualityTestMap.find(pQualityTest->getName());

	if(m_qualityTestMap.end() != findIter)
		return STATUS_CODE_ALREADY_PRESENT;

	if(!m_qualityTestMap.insert(std::map<std::string, DQMQualityTest*>::value_type(pQualityTest->getName(), pQualityTest)).second)
		return STATUS_CODE_FAILURE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::removeQualityTest(DQMQualityTest *pQualityTest)
{
	if(NULL == pQualityTest)
		return STATUS_CODE_INVALID_PTR;

	return removeQualityTest(pQualityTest->getName());
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::removeQualityTest(const std::string &qualityTestName)
{
	std::map<std::string, DQMQualityTest*>::iterator findIter = m_qualityTestMap.find(qualityTestName);

	if(m_qualityTestMap.end() == findIter)
		return STATUS_CODE_NOT_FOUND;

	m_qualityTestMap.erase(findIter);

	return STATUS_CODE_SUCCESS;
}

} 

