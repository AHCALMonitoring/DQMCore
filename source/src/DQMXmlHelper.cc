  /// \file DQMXmlHelper.cc
/*
 *
 * DQMXmlHelper.cc source template automatically generated by a class generator
 * Creation date : mar. juil. 1 2014
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMModule.h"

namespace dqm4hep
{

//----------------------------------------------------------------------------------------------------

void DQMXmlHelper::tokenizeString(const std::string &inputString, StringVector &tokens, const std::string &delimiter)
{
    std::string::size_type lastPos = inputString.find_first_not_of(delimiter, 0);
    std::string::size_type pos     = inputString.find_first_of(delimiter, lastPos);

    while ((std::string::npos != pos) || (std::string::npos != lastPos))
    {
        tokens.push_back(inputString.substr(lastPos, pos - lastPos));
        lastPos = inputString.find_first_not_of(delimiter, pos);
        pos = inputString.find_first_of(delimiter, lastPos);
    }
}

//----------------------------------------------------------------------------------------------------

StatusCode DQMXmlHelper::createQualityTest(const DQMModule *const pModule, const TiXmlHandle &xmlHandle, const std::string &qualityTestName)
{
    for (TiXmlElement *pXmlElement = xmlHandle.FirstChild("qualitytest").Element(); NULL != pXmlElement;
        pXmlElement = pXmlElement->NextSiblingElement("qualitytest"))
    {
    	std::string name;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "name", name));

    	if(name != qualityTestName)
    		continue;

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::createQualityTest(pModule, pXmlElement));

    	return STATUS_CODE_SUCCESS;
    }

    return STATUS_CODE_NOT_FOUND;
}

//----------------------------------------------------------------------------------------------------

StatusCode DQMXmlHelper::bookMonitorElement(const DQMModule *const pModule, const TiXmlHandle &xmlHandle, const std::string &meStringId,
		DQMMonitorElement *&pMonitorElement)
{
    for (TiXmlElement *pXmlElement = xmlHandle.FirstChild("monitorElement").Element(); NULL != pXmlElement;
        pXmlElement = pXmlElement->NextSiblingElement("monitorElement"))
    {
    	std::string meId;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "ID", meId));

    	if(meId != meStringId)
    		continue;

    	return DQMModuleApi::bookMonitorElement(pModule, pXmlElement, pMonitorElement);
    }

	return STATUS_CODE_NOT_FOUND;
}


}
