  /// \file DQMPerformance.cc
/*
 *
 * DQMPerformance.cc source template automatically generated by a class generator
 * Creation date : mar. janv. 26 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/DQMPerformance.h"

#include <algorithm>

namespace dqm4hep
{

DQMPerformanceService::DQMPerformanceService(const std::string &varName, float &var) :
	DimService( (char *) ("/DQM4HEP/PERFORMANCE/" + varName).c_str() , var)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------


DQMPerformanceInfo::DQMPerformanceInfo(DQMPerformanceManager *pPerformanceManager, const std::string &varName, float nolink) :
		m_pPerformanceManager(pPerformanceManager),
		DimInfo( (char *) ("/DQM4HEP/PERFORMANCE/" + varName).c_str(), nolink, pPerformanceManager),
		m_varName(varName)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMPerformanceInfo::getVarName() const
{
	return m_varName;
}

//-------------------------------------------------------------------------------------------------

void DQMPerformanceInfo::infoHandler()
{
	if(m_pPerformanceManager)
		m_pPerformanceManager->handlePerformance(this);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMPerformanceManager::DQMPerformanceManager()
{
	this->scanPerformanceInfo();
}

//-------------------------------------------------------------------------------------------------

DQMPerformanceManager::~DQMPerformanceManager()
{
	this->clear();
}

//-------------------------------------------------------------------------------------------------

void DQMPerformanceManager::handlePerformance(DQMPerformanceInfo *pInfo)
{
	std::map<std::string, std::vector<float> >::iterator findIter = m_performanceContentsMap.find(pInfo->getVarName());

	if(findIter == m_performanceContentsMap.end())
		return;

	if(findIter->second.max_size() == findIter->second.size())
	{
		std::cout << "WARNING ! Maximum vector size reached (" << findIter->second.max_size() << "). \n"
				"Couldn't add more values to performance contents vector (" << findIter->first << ")" << std::endl;
		return;
	}

	findIter->second.push_back(pInfo->getFloat());
}

//-------------------------------------------------------------------------------------------------

void DQMPerformanceManager::scanPerformanceInfo()
{
	DimBrowser browser;
	browser.getServices("/DQM4HEP/PERFORMANCE/*");

	char *service, *format;
	int type;
	while(type = browser.getNextService(service, format))
	{
		std::string serviceName(service);
		std::string varName = serviceName.substr(std::string("/DQM4HEP/PERFORMANCE/").size());

		std::cout << "Var name : " << varName << std::endl;

		DQMPerformanceInfo *pInfo = new DQMPerformanceInfo(this, varName, 0.f);

		m_performanceInfoMap[varName] = pInfo;
		m_performanceContentsMap[varName]; // just create the map entry
	}

	std::cout << "N performance vars found = " << m_performanceInfoMap.size() << std::endl;
}

//-------------------------------------------------------------------------------------------------

void DQMPerformanceManager::clear()
{
	for(std::map<std::string, DQMPerformanceInfo *>::iterator iter = m_performanceInfoMap.begin(), endIter = m_performanceInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		delete iter->second;
	}

	m_performanceInfoMap.clear();
}

//-------------------------------------------------------------------------------------------------

std::map<std::string, TH1F *> DQMPerformanceManager::createHistograms()
{
	std::map<std::string, TH1F *> histogramMap;

	for(std::map<std::string, std::vector<float> >::iterator iter = m_performanceContentsMap.begin(), endIter = m_performanceContentsMap.end() ;
			endIter != iter ; ++iter)
	{
		float min = *std::min_element(iter->second.begin(), iter->second.end());
		float max = *std::max_element(iter->second.begin(), iter->second.end());
		int nBins = 1000;

		TH1F *pHistogram = new TH1F(iter->first.c_str(), iter->first.c_str(), nBins, min, max);

		for(std::vector<float>::iterator cIter = iter->second.begin(), cEndIter = iter->second.end() ;
				cEndIter != cIter ; ++cIter)
		{
			pHistogram->Fill(*cIter);
		}

		histogramMap[iter->first] = pHistogram;
	}

	return histogramMap;
}

//-------------------------------------------------------------------------------------------------

void DQMPerformanceManager::printStats() const
{
	std::cout << "***********************************" << std::endl;

	for(std::map<std::string, std::vector<float> >::const_iterator iter = m_performanceContentsMap.begin(), endIter = m_performanceContentsMap.end() ;
			endIter != iter ; ++iter)
	{
		std::cout << "Var : " << iter->first << " , stats = " << iter->second.size() << std::endl;
	}

	std::cout << "***********************************" << std::endl;
}

//-------------------------------------------------------------------------------------------------

void DQMPerformanceManager::infoHandler()
{
	DQMPerformanceInfo *pInfo = (DQMPerformanceInfo *) getInfo();

	if(!pInfo)
		return;

	this->handlePerformance(pInfo);
}

} 

