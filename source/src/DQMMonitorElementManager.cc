  /// \file DQMMonitorElementManager.cc
/*
 *
 * DQMMonitorElementManager.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElementManager.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMStorage.h"
#include "dqm4hep/DQMDirectory.h"
#include "dqm4hep/DQMCoreTool.h"
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMPluginManager.h"
#include "dqm4hep/DQMQualityTest.h"

// -- root headers
#include "TH1F.h"
#include "TH1I.h"
#include "TH1S.h"
#include "TH1C.h"
#include "TH2F.h"
#include "TH2I.h"
#include "TH2S.h"
#include "TH2C.h"
#include "TH3F.h"
#include "TH3I.h"
#include "TProfile.h"
#include "TProfile2D.h"
#include "TROOT.h"
#include "TClass.h"
#include "TObject.h"

// -- std headers
#include <stdexcept>

namespace dqm4hep
{

DQMMonitorElementManager::DQMMonitorElementManager() 
{
	m_pMonitorElementStorage = new DQMStorage();
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementManager::~DQMMonitorElementManager() 
{
	delete m_pMonitorElementStorage;

	for(DQMQualityTestFactoryMap::iterator iter = m_qualityTestFactoryMap.begin(), endIter = m_qualityTestFactoryMap.end() ;
			endIter != iter ; ++iter)
		delete iter->second;

	for(DQMQualityTestMap::iterator iter = m_qualityTestMap.begin(), endIter = m_qualityTestMap.end() ;
			endIter != iter ; ++iter)
		delete iter->second;

	m_qualityTestFactoryMap.clear();
	m_qualityTestMap.clear();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementManager::cd()
{
	m_pMonitorElementStorage->cd();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::cd(const std::string &dirName)
{
	return m_pMonitorElementStorage->cd(dirName);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::mkdir(const std::string &dirName)
{
	return m_pMonitorElementStorage->mkdir(dirName);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementManager::ls(bool recursive)
{
	m_pMonitorElementStorage->ls(recursive);
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementManager::pwd()
{
	return m_pMonitorElementStorage->pwd();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::goUp()
{
	return m_pMonitorElementStorage->goUp();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::rmdir(const std::string &dirName)
{
	return m_pMonitorElementStorage->rmdir(dirName);
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementManager::getCurrentDirectoryName() const
{
	return m_pMonitorElementStorage->getCurrentDirectory()->getName();
}

//-------------------------------------------------------------------------------------------------

DQMPath DQMMonitorElementManager::getCurrentDirectoryFullPathName() const
{
	return m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getFullPathName(const std::string &subDirName, DQMPath &fullPathName) const
{
	DQMDirectory *pDirectory = NULL;
	THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(subDirName, pDirectory));

	fullPathName = pDirectory->getFullPathName();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH1F(objectName.c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH1I(objectName.c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookCharHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH1C(objectName.c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, CHAR_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShortHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH1S(objectName.c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, SHORT_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH2F(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH2I(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookCharHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH2C(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, CHAR_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShortHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH2S(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, SHORT_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram3D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax,
		int nZBins, float zMin, float zMax)
{
	pMonitorElement = NULL;
	TH3 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH3F(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax, nZBins, zMin, zMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_3D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram3D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax,
		int nZBins, float zMin, float zMax)
{
	pMonitorElement = NULL;
	TH3 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pHistogram = new TH3I(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax, nZBins, zMin, zMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_3D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookProfile1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TProfile *pProfile = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pProfile = new TProfile(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, yMin, yMax);

		if(NULL == pProfile)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pProfile, PROFILE_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pProfile)
			delete pProfile;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookProfile2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax, float zMin, float zMax)
{
	pMonitorElement = NULL;
	TProfile2D *pProfile = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMPath currentDirPath = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
		std::string objectName = (currentDirPath + name).getPath();

		// create the histogram first
		pProfile = new TProfile2D(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax, zMin, zMax);

		if(NULL == pProfile)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pProfile, PROFILE_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pProfile)
			delete pProfile;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookInt(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, const int &value)
{
	pMonitorElement = NULL;
	TScalarInt *pScalarObject = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarInt(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, INT_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookFloat(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, const float &value)
{
	pMonitorElement = NULL;
	TScalarFloat *pScalarObject = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarFloat(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, REAL_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShort(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, const short &value)
{
	pMonitorElement = NULL;
	TScalarShort *pScalarObject = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarShort(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, SHORT_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookString(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, const std::string &value)
{
	pMonitorElement = NULL;
	TScalarString *pScalarObject = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarString(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, STRING_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookObject(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, const std::string &className)
{
	pMonitorElement = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
    	TClass *pClass = gROOT->GetClass(className.c_str());

    	if(!pClass)
    		return STATUS_CODE_FAILURE;

    	TObject *pObject = reinterpret_cast<TObject *>(pClass->New());

    	if(!pObject)
    		return STATUS_CODE_FAILURE;

		// create the monitor element
		pMonitorElement = new DQMMonitorElement(pObject, USER_DEFINED_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH1F(objectName.c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH1I(objectName.c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookCharHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH1C(objectName.c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, CHAR_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShortHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH1S(objectName.c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, SHORT_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH2F(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH2I(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookCharHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH2C(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, CHAR_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShortHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH2S(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, SHORT_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram3D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax, int nZBins, float zMin, float zMax)
{
	pMonitorElement = NULL;
	TH3 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH3F(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax, nZBins, zMin, zMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_3D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram3D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax, int nZBins, float zMin, float zMax)
{
	pMonitorElement = NULL;
	TH3 *pHistogram = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pHistogram = new TH3I(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax, nZBins, zMin, zMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_3D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookProfile1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TProfile *pProfile = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pProfile = new TProfile(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, yMin, yMax);

		if(NULL == pProfile)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pProfile, PROFILE_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pProfile)
			delete pProfile;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookProfile2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax, float zMin, float zMax)
{
	pMonitorElement = NULL;
	TProfile2D *pProfile = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string objectName = (pDirectory->getFullPathName() + name).getPath();

		// create the histogram first
		pProfile = new TProfile2D(objectName.c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax, zMin, zMax);

		if(NULL == pProfile)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pProfile, PROFILE_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pProfile)
			delete pProfile;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookInt(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, const int &value)
{
	pMonitorElement = NULL;
	TScalarInt *pScalarObject = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarInt(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, INT_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookFloat(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, const float &value)
{
	pMonitorElement = NULL;
	TScalarFloat *pScalarObject = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarFloat(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, REAL_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShort(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, const short &value)
{
	pMonitorElement = NULL;
	TScalarShort *pScalarObject = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarShort(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, SHORT_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookString(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, const std::string &value)
{
	pMonitorElement = NULL;
	TScalarString *pScalarObject = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarString(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, STRING_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookObject(DQMMonitorElement *&pMonitorElement, const std::string &directory, const std::string &name, const std::string &title,
		const std::string &moduleName, const std::string &className)
{
	pMonitorElement = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
    	TClass *pClass = gROOT->GetClass(className.c_str());

    	if(!pClass)
    		return STATUS_CODE_FAILURE;

    	TObject *pObject = reinterpret_cast<TObject *>(pClass->New());

    	if(!pObject)
    		return STATUS_CODE_FAILURE;

		// create the monitor element
		pMonitorElement = new DQMMonitorElement(pObject, USER_DEFINED_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(directory, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookMonitorElement(const TiXmlElement *const pXmlElement, const std::string &moduleName,
		const std::string &name, DQMMonitorElement *&pMonitorElement)
{
	if(NULL == pXmlElement)
		return STATUS_CODE_INVALID_PTR;

	std::string type;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "type", type));

	DQMMonitorElementType monitorElementType = stringToMonitorElementRootType(type);

	if(NO_ELEMENT_TYPE == monitorElementType || monitorElementType >= NUMBER_OF_DQM_MONITOR_ELEMENT_TYPES)
		return STATUS_CODE_INVALID_PARAMETER;

	// empty path means current directory
	std::string path;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "path", path));

	// create dir
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_ALREADY_PRESENT, !=, this->mkdir(path));

	// not mandatory
	std::string title;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "title", title));

	// not mandatory
	std::string description;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "description", description));

	// not mandatory
	std::string drawOption;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "drawOption", drawOption));

	// not mandatory
	std::string resetPolicyStr;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "resetPolicy", resetPolicyStr));

	// for scalar values
	std::string value;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "value", value));

	switch(monitorElementType)
	{
	case INT_ELEMENT_TYPE :
	{

		int intValue;

		if(!DQM4HEP::stringToType(value, intValue))
			return STATUS_CODE_FAILURE;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookInt(pMonitorElement, path, name, title, moduleName, intValue));

		break;
	}
	case REAL_ELEMENT_TYPE :
	{
		float floatValue;

		if(!DQM4HEP::stringToType(value, floatValue))
			return STATUS_CODE_FAILURE;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookFloat(pMonitorElement, path, name, title, moduleName, floatValue));

		break;
	}
	case SHORT_ELEMENT_TYPE :
	{

		short shortValue;

		if(!DQM4HEP::stringToType(value, shortValue))
			return STATUS_CODE_FAILURE;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookShort(pMonitorElement, path, name, title, moduleName, shortValue));

		break;
	}
	case STRING_ELEMENT_TYPE :
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookString(pMonitorElement, path, name, title, moduleName, value));

		break;
	}
	case INT_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookIntHistogram1D(pMonitorElement, path, name, title, moduleName, nBins, min, max));

    	break;
	}
	case REAL_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookRealHistogram1D(pMonitorElement, path, name, title, moduleName, nBins, min, max));

    	break;
	}
	case SHORT_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookShortHistogram1D(pMonitorElement, path, name, title, moduleName, nBins, min, max));

    	break;
	}
	case CHAR_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookCharHistogram1D(pMonitorElement, path, name, title, moduleName, nBins, min, max));

    	break;
	}
	case INT_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookIntHistogram2D(pMonitorElement, path, name, title, moduleName, nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case REAL_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookRealHistogram2D(pMonitorElement, path, name, title, moduleName, nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case CHAR_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookCharHistogram2D(pMonitorElement, path, name, title, moduleName, nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case SHORT_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookShortHistogram2D(pMonitorElement, path, name, title, moduleName, nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case INT_HISTOGRAM_3D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

		int nBinsZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsZ", nBinsZ, &PositiveValidator<int>::validate ));
    	float minZ, maxZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minZ", minZ));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxZ", maxZ, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookIntHistogram3D(pMonitorElement, path, name, title, moduleName, nBinsX, minX, maxX, nBinsY, minY, maxY, nBinsZ, minZ, maxZ));

    	break;
	}
	case REAL_HISTOGRAM_3D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

		int nBinsZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsZ", nBinsZ, &PositiveValidator<int>::validate ));
    	float minZ, maxZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minZ", minZ));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxZ", maxZ, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookRealHistogram3D(pMonitorElement, path, name, title, moduleName, nBinsX, minX, maxX, nBinsY, minY, maxY, nBinsZ, minZ, maxZ));

    	break;
	}
	case PROFILE_1D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxX, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookProfile1D(pMonitorElement, path, name, title, moduleName, nBinsX, minX, maxX, minY, maxY));

    	break;
	}
	case PROFILE_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	float minZ, maxZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minZ", minZ));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxZ", maxZ, BiggerThanValidator<float>(minZ) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookProfile2D(pMonitorElement, path, name, title, moduleName, nBinsX, minX, maxX, nBinsY, minY, maxY, minZ, maxZ));

    	break;
	}
	case USER_DEFINED_ELEMENT_TYPE :
	{
		std::string rootClass;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "ROOTClass", rootClass));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(pMonitorElement, path, name, title, moduleName, rootClass));

    	break;
	}
	default:
		return STATUS_CODE_FAILURE;
	}

	pMonitorElement->setDrawOption(drawOption);
	pMonitorElement->setDescription(description);
	pMonitorElement->setResetPolicy(stringToResetPolicy(resetPolicyStr));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getAllMonitorElements(std::vector<DQMMonitorElement*> &monitorElementList) const
{
	return m_pMonitorElementStorage->getAllMonitorElements(monitorElementList);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getMonitorElement(const std::string &monitorElementName, DQMMonitorElement *&pMonitorElement) const
{
	return m_pMonitorElementStorage->getMonitorElement(monitorElementName, pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getMonitorElement(const std::string &dirName, const std::string &monitorElementName, DQMMonitorElement *&pMonitorElement) const
{
	return m_pMonitorElementStorage->getMonitorElement(dirName, monitorElementName, pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElement *DQMMonitorElementManager::getMonitorElement(const std::string &monitorElementName) const
{
	DQMMonitorElement *pMonitorElement = NULL;
	this->getMonitorElement(monitorElementName, pMonitorElement);
	return pMonitorElement;
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElement *DQMMonitorElementManager::getMonitorElement(const std::string &dirName, const std::string &monitorElementName) const
{
	DQMMonitorElement *pMonitorElement = NULL;
	this->getMonitorElement(dirName, monitorElementName, pMonitorElement);
	return pMonitorElement;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::deleteMonitorElement(DQMMonitorElement *pMonitorElement)
{
	if(NULL == pMonitorElement)
		return STATUS_CODE_INVALID_PTR;

	const std::string fullPath = pMonitorElement->getPath().getPath();
	const std::string name = pMonitorElement->getName();

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->removeMonitorElement(fullPath, name));

	if(!m_pMonitorElementStorage->isOwner() && NULL != pMonitorElement)
		delete pMonitorElement;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::deleteMonitorElement(const std::string &dirName, const std::string &monitorElementName)
{
	if(m_pMonitorElementStorage->isOwner())
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->removeMonitorElement(dirName, monitorElementName));
	}
	else
	{
		DQMMonitorElement *pMonitorElement = NULL;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->getMonitorElement(dirName, monitorElementName, pMonitorElement));
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->removeMonitorElement(dirName, monitorElementName));

		if(NULL != pMonitorElement)
			delete pMonitorElement;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::resetMonitorElements(DQMResetPolicy policy) const
{
	DQMMonitorElementList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	for(DQMMonitorElementList::iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		DQMMonitorElement *pMonitorElement = *iter;

		if(NULL == pMonitorElement)
			continue;

		if(policy == pMonitorElement->getResetPolicy())
			pMonitorElement->reset();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::resetMonitorElements() const
{
	DQMMonitorElementList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	for(DQMMonitorElementList::iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		DQMMonitorElement *pMonitorElement = *iter;

		if(NULL == pMonitorElement)
			continue;

		pMonitorElement->reset();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getMonitorElementListToPublish(DQMMonitorElementList &monitorElementListToPublish) const
{
	DQMMonitorElementList moduleElementList;
	RETURN_RESULT_IF( STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements( moduleElementList ) );

	for( DQMMonitorElementList::const_iterator iter = moduleElementList.begin(), endIter = moduleElementList.end() ;
			endIter != iter ; ++iter )
	{
		DQMMonitorElement *pMonitorElement = *iter;

		if( pMonitorElement->isToPublish() )
			monitorElementListToPublish.push_back( pMonitorElement );
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

//StatusCode DQMMonitorElementManager::archive(DQMArchiver *pArchiver)
//{
//	if(NULL == pArchiver)
//		return STATUS_CODE_INVALID_PTR;
//
//	// TODO implements this in DQMArchiver
////	return pArchiver->archive(pModule);
//	return STATUS_CODE_FAILURE;
//}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------


StatusCode DQMMonitorElementManager::registerQualityTestFactory(const std::string &qualityTestFactoryName, const DQMQualityTestFactory *const pQualityTestFactory)
{
	if(NULL == pQualityTestFactory)
		return STATUS_CODE_INVALID_PTR;

	DQMQualityTestFactoryMap::iterator findIter = m_qualityTestFactoryMap.find(qualityTestFactoryName);

	if(m_qualityTestFactoryMap.end() != findIter)
	{
		delete pQualityTestFactory;
		return STATUS_CODE_ALREADY_PRESENT;
	}

	m_qualityTestFactoryMap[qualityTestFactoryName] = pQualityTestFactory;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::createQualityTest(TiXmlElement *const pXmlElement)
{
	std::string name;
	std::string type;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "name", name));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "type", type));

	DQMQualityTestMap::iterator findIter = m_qualityTestMap.find(name);

	if(m_qualityTestMap.end() != findIter)
		return STATUS_CODE_ALREADY_PRESENT;

	DQMQualityTestFactoryMap::iterator findFactoryIter = m_qualityTestFactoryMap.find(type);

	if(m_qualityTestFactoryMap.end() == findFactoryIter)
			return STATUS_CODE_NOT_FOUND;

	DQMQualityTest *const pQualityTest = findFactoryIter->second->createQualityTest(name);
	pQualityTest->m_type = type;

	try
	{
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->readSettings(TiXmlHandle(pXmlElement)));
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->init());

		if(!m_qualityTestMap.insert(DQMQualityTestMap::value_type(name, pQualityTest)).second)
			throw StatusCodeException(STATUS_CODE_FAILURE);
	}
	catch(const StatusCodeException &exception)
	{
		delete pQualityTest;
		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::addQualityTest(DQMMonitorElement *pMonitorElement, const std::string &qualityTestName) const
{
	if(NULL == pMonitorElement)
		return STATUS_CODE_INVALID_PTR;

	DQMQualityTest *pQualityTest = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getQualityTest(qualityTestName, pQualityTest));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pMonitorElement->addQualityTest(pQualityTest));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTests(DQMMonitorElement *pMonitorElement)
{
	if(NULL == pMonitorElement)
		return STATUS_CODE_INVALID_PTR;

	return pMonitorElement->runQualityTests();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTest(DQMMonitorElement *pMonitorElement, const std::string &qualityTestName)
{
	if(NULL == pMonitorElement)
		return STATUS_CODE_INVALID_PTR;

	return pMonitorElement->runQualityTest(qualityTestName);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTests()
{
	DQMMonitorElementList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	return this->runQualityTests(monitorElementList);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTests(const DQMMonitorElementList &monitorElementList)
{
	for(DQMMonitorElementList::const_iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->runQualityTests(*iter));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getQualityTest(const std::string &qualityTestName, DQMQualityTest *&pQualityTest) const
{
	pQualityTest = NULL;

	// look for an existing quality test in the map
	DQMQualityTestMap::const_iterator qTestFindIter = m_qualityTestMap.find(qualityTestName);

	if(m_qualityTestMap.end() == qTestFindIter)
		return STATUS_CODE_NOT_FOUND;

	pQualityTest = qTestFindIter->second;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getQualityTestResults(DQMQualityTestResultMap &results) const
{
	DQMMonitorElementList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	for( DQMMonitorElementList::const_iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter )
	{
		DQMMonitorElement *pMonitorElement = *iter;

		const DQMQualityTestResultMap &meResults(pMonitorElement->getQualityTestResults());
		results.insert(meResults.begin(), meResults.end());
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMStorage *DQMMonitorElementManager::getStorage() const
{
	return m_pMonitorElementStorage;
}

} 

