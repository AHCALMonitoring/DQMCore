  /// \file DQMMonitorElementManager.cc
/*
 *
 * DQMMonitorElementManager.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElementManager.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMStorage.h"
#include "dqm4hep/DQMDirectory.h"
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMPluginManager.h"
#include "dqm4hep/DQMQualityTest.h"

// -- root headers
#include "TH1F.h"
#include "TH1I.h"
#include "TH1S.h"
#include "TH1C.h"
#include "TH2F.h"
#include "TH2I.h"
#include "TH2S.h"
#include "TH2C.h"
#include "TProfile.h"
#include "TProfile2D.h"

// -- std headers
#include <stdexcept>

namespace dqm4hep
{

DQMMonitorElementManager::DQMMonitorElementManager() 
{
	m_pMonitorElementStorage = new DQMStorage();
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementManager::~DQMMonitorElementManager() 
{
	delete m_pMonitorElementStorage;

	for(DQMQualityTestFactoryMap::iterator iter = m_qualityTestFactoryMap.begin(), endIter = m_qualityTestFactoryMap.end() ;
			endIter != iter ; ++iter)
		delete iter->second;

	for(DQMQualityTestMap::iterator iter = m_qualityTestMap.begin(), endIter = m_qualityTestMap.end() ;
			endIter != iter ; ++iter)
		delete iter->second;

	m_qualityTestFactoryMap.clear();
	m_qualityTestMap.clear();
}

//-------------------------------------------------------------------------------------------------

//StatusCode DQMMonitorElementManager::readSettings(const TiXmlHandle xmlHandle)
//{
//    for (TiXmlElement *pXmlElement = xmlHandle.FirstChild("qualitytest").Element(); NULL != pXmlElement;
//        pXmlElement = pXmlElement->NextSiblingElement("qualitytest"))
//    {
//    	std::string type;
//    	std::string name;
//
//    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "type", type));
//    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "name", name));
//
//    	DQMQualityTestMap::const_iterator findIter = m_qualityTestMap.find(name);
//
//    	if(m_qualityTestMap.end() != findIter)
//    	{
//    		streamlog_out(WARNING) << "Quality test '" << name << "' is already registered ! \n Skipping" << std::endl;
//    		continue;
//    	}
//
//    	DQMQualityTest *pQualityTest = NULL;
//    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->createQualityTest(type, name, pQualityTest));
//
//    	TiXmlHandle qTestHandle(pXmlElement);
//
//    	if(STATUS_CODE_SUCCESS != pQualityTest->readSettings(qTestHandle)
//    	|| STATUS_CODE_SUCCESS != pQualityTest->init())
//    	{
//    		streamlog_out(WARNING) << "Couldn't initialize quality test '" << name << "' ! \n Skipping" << std::endl;
//    		delete pQualityTest;
//
//    		continue;
//    	}
//
//    	m_qualityTestMap[name] = pQualityTest;
//    }
//
//	return STATUS_CODE_SUCCESS;
//}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementManager::cd()
{
	m_pMonitorElementStorage->cd();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::cd(const std::string &dirName)
{
	return m_pMonitorElementStorage->cd(dirName);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::mkdir(const std::string &dirName)
{
	return m_pMonitorElementStorage->mkdir(dirName);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementManager::ls(bool recursive)
{
	m_pMonitorElementStorage->ls(recursive);
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementManager::pwd()
{
	return m_pMonitorElementStorage->pwd();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::goUp()
{
	return m_pMonitorElementStorage->goUp();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::rmdir(const std::string &dirName)
{
	return m_pMonitorElementStorage->rmdir(dirName);
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementManager::getCurrentDirectoryName() const
{
	return m_pMonitorElementStorage->getCurrentDirectory()->getName();
}

//-------------------------------------------------------------------------------------------------

std::string DQMMonitorElementManager::getCurrentDirectoryFullPathName() const
{
	return m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getFullPathName(const std::string &subDirName, std::string &fullPathName) const
{
	DQMDirectory *pDirectory = NULL;
	THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(subDirName, pDirectory));

	fullPathName = pDirectory->getFullPathName();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH1F((currentDirName + name).c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH1I((currentDirName + name).c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookCharHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH1C((currentDirName + name).c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, CHAR_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShortHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH1S((currentDirName + name).c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, SHORT_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH2F((currentDirName + name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH2I((currentDirName + name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookCharHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH2C((currentDirName + name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, CHAR_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShortHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH2S((currentDirName + name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, SHORT_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookProfile1D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TProfile *pProfile = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pProfile = new TProfile((currentDirName + name).c_str(), title.c_str(), nXBins, xMin, xMax, yMin, yMax);

		if(NULL == pProfile)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pProfile, PROFILE_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pProfile)
			delete pProfile;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookProfile2D(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax, float zMin, float zMax)
{
	pMonitorElement = NULL;
	TProfile2D *pProfile = NULL;

	try
	{
		std::string currentDirName = m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName() + "/";

		// create the histogram first
		pProfile = new TProfile2D((currentDirName + name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax, zMin, zMax);

		if(NULL == pProfile)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pProfile, PROFILE_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pProfile)
			delete pProfile;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookInt(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, const int &value)
{
	pMonitorElement = NULL;
	TScalarInt *pScalarObject = NULL;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarInt(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, INT_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookFloat(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, const float &value)
{
	pMonitorElement = NULL;
	TScalarFloat *pScalarObject = NULL;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarFloat(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, REAL_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShort(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, const short &value)
{
	pMonitorElement = NULL;
	TScalarShort *pScalarObject = NULL;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarShort(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, SHORT_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookString(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, const std::string &value)
{
	pMonitorElement = NULL;
	TScalarString *pScalarObject = NULL;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarString(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, STRING_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookObject(DQMMonitorElement *&pMonitorElement, const std::string &name, const std::string &title,
		const std::string &moduleName, TObject *pROOTObject)
{
	pMonitorElement = NULL;

	try
	{
//		// check if the root class passed by user has a dictionary
//		// and thus can be handled by root i/o streamers
//		if(!pROOTObject->IsA()->HasDictionary())
//			throw StatusCodeException(STATUS_CODE_FAILURE);

		// create the monitor element
		pMonitorElement = new DQMMonitorElement(pROOTObject, USER_DEFINED_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH1F((fullPath+name).c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH1I((fullPath+name).c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookCharHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH1C((fullPath+name).c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, CHAR_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShortHistogram1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nBins, float minimum, float maximum)
{
	pMonitorElement = NULL;
	TH1 *pHistogram = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH1S((fullPath+name).c_str(), title.c_str(), nBins, minimum, maximum);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, SHORT_HISTOGRAM_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookRealHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH2F((fullPath+name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, REAL_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookIntHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH2I((fullPath+name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, INT_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookCharHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH2C((fullPath+name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, CHAR_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShortHistogram2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TH2 *pHistogram = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pHistogram = new TH2S((fullPath+name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax);

		if(NULL == pHistogram)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pHistogram, SHORT_HISTOGRAM_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pHistogram)
			delete pHistogram;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookProfile1D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, float yMin, float yMax)
{
	pMonitorElement = NULL;
	TProfile *pProfile = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pProfile = new TProfile((fullPath+name).c_str(), title.c_str(), nXBins, xMin, xMax, yMin, yMax);

		if(NULL == pProfile)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pProfile, PROFILE_1D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pProfile)
			delete pProfile;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookProfile2D(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, int nXBins, float xMin, float xMax, int nYBins, float yMin, float yMax, float zMin, float zMax)
{
	pMonitorElement = NULL;
	TProfile2D *pProfile = NULL;

	try
	{
		DQMDirectory *pDirectory = NULL;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(dirName, pDirectory));
		std::string fullPath = pDirectory->getFullPathName() + "/";

		// create the histogram first
		pProfile = new TProfile2D((fullPath+name).c_str(), title.c_str(), nXBins, xMin, xMax, nYBins, yMin, yMax, zMin, zMax);

		if(NULL == pProfile)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pProfile, PROFILE_2D_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pProfile)
			delete pProfile;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookInt(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, const int &value)
{
	pMonitorElement = NULL;
	TScalarInt *pScalarObject = NULL;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarInt(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, INT_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookFloat(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, const float &value)
{
	pMonitorElement = NULL;
	TScalarFloat *pScalarObject = NULL;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarFloat(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, REAL_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookShort(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, const short &value)
{
	pMonitorElement = NULL;
	TScalarShort *pScalarObject = NULL;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarShort(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, SHORT_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookString(DQMMonitorElement *&pMonitorElement, const std::string &dirName, const std::string &name, const std::string &title,
		const std::string &moduleName, const std::string &value)
{
	pMonitorElement = NULL;
	TScalarString *pScalarObject = NULL;

	try
	{
		// create the histogram first
		pScalarObject = new TScalarString(value);

		if(NULL == pScalarObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// and the monitor element
		pMonitorElement = new DQMMonitorElement(pScalarObject, STRING_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(dirName, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pScalarObject)
			delete pScalarObject;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookObject(DQMMonitorElement *&pMonitorElement, const std::string &directory, const std::string &name, const std::string &title,
		const std::string &moduleName, TObject *pROOTObject)
{
	pMonitorElement = NULL;

	try
	{
//		// check if the root class passed by user has a dictionary
//		// and thus can be handled by root i/o streamers
//		if(!pROOTObject->IsA()->HasDictionnary())
//			throw StatusCodeException(STATUS_CODE_FAILURE);

		// create the monitor element
		pMonitorElement = new DQMMonitorElement(pROOTObject, USER_DEFINED_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == pMonitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(directory, pMonitorElement));
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() << std::endl;

		if(NULL != pMonitorElement)
			delete pMonitorElement;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getAllMonitorElements(std::vector<DQMMonitorElement*> &monitorElementList) const
{
	return m_pMonitorElementStorage->getAllMonitorElements(monitorElementList);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getMonitorElement(const std::string &monitorElementName, DQMMonitorElement *&pMonitorElement) const
{
	return m_pMonitorElementStorage->getMonitorElement(monitorElementName, pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getMonitorElement(const std::string &dirName, const std::string &monitorElementName, DQMMonitorElement *&pMonitorElement) const
{
	return m_pMonitorElementStorage->getMonitorElement(dirName, monitorElementName, pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElement *DQMMonitorElementManager::getMonitorElement(const std::string &monitorElementName) const
{
	DQMMonitorElement *pMonitorElement = NULL;
	this->getMonitorElement(monitorElementName, pMonitorElement);
	return pMonitorElement;
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElement *DQMMonitorElementManager::getMonitorElement(const std::string &dirName, const std::string &monitorElementName) const
{
	DQMMonitorElement *pMonitorElement = NULL;
	this->getMonitorElement(dirName, monitorElementName, pMonitorElement);
	return pMonitorElement;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::deleteMonitorElement(DQMMonitorElement *pMonitorElement)
{
	if(NULL == pMonitorElement)
		return STATUS_CODE_INVALID_PTR;

	const std::string fullPath = pMonitorElement->getFullPath();
	const std::string name = pMonitorElement->getName();

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->removeMonitorElement(fullPath, name));

	if(!m_pMonitorElementStorage->isOwner() && NULL != pMonitorElement)
		delete pMonitorElement;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::deleteMonitorElement(const std::string &dirName, const std::string &monitorElementName)
{
	if(m_pMonitorElementStorage->isOwner())
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->removeMonitorElement(dirName, monitorElementName));
	}
	else
	{
		DQMMonitorElement *pMonitorElement = NULL;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->getMonitorElement(dirName, monitorElementName, pMonitorElement));
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->removeMonitorElement(dirName, monitorElementName));

		if(NULL != pMonitorElement)
			delete pMonitorElement;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::resetMonitorElements(DQMResetPolicy policy) const
{
	DQMMonitorElementList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	for(DQMMonitorElementList::iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		DQMMonitorElement *pMonitorElement = *iter;

		if(NULL == pMonitorElement)
			continue;

		if(policy == pMonitorElement->getResetPolicy())
			pMonitorElement->reset();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::resetMonitorElements() const
{
	DQMMonitorElementList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	for(DQMMonitorElementList::iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		DQMMonitorElement *pMonitorElement = *iter;

		if(NULL == pMonitorElement)
			continue;

		pMonitorElement->reset();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getMonitorElementListToPublish(DQMMonitorElementList &monitorElementListToPublish) const
{
	DQMMonitorElementList moduleElementList;
	RETURN_RESULT_IF( STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements( moduleElementList ) );

	for( DQMMonitorElementList::const_iterator iter = moduleElementList.begin(), endIter = moduleElementList.end() ;
			endIter != iter ; ++iter )
	{
		DQMMonitorElement *pMonitorElement = *iter;

		if( pMonitorElement->isToPublish() )
			monitorElementListToPublish.push_back( pMonitorElement );
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

//StatusCode DQMMonitorElementManager::archive(DQMArchiver *pArchiver)
//{
//	if(NULL == pArchiver)
//		return STATUS_CODE_INVALID_PTR;
//
//	// TODO implements this in DQMArchiver
////	return pArchiver->archive(pModule);
//	return STATUS_CODE_FAILURE;
//}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------


StatusCode DQMMonitorElementManager::registerQualityTestFactory(const std::string &qualityTestFactoryName, const DQMQualityTestFactory *const pQualityTestFactory)
{
	if(NULL == pQualityTestFactory)
		return STATUS_CODE_INVALID_PTR;

	DQMQualityTestFactoryMap::iterator findIter = m_qualityTestFactoryMap.find(qualityTestFactoryName);

	if(m_qualityTestFactoryMap.end() != findIter)
	{
		delete pQualityTestFactory;
		return STATUS_CODE_ALREADY_PRESENT;
	}

	m_qualityTestFactoryMap[qualityTestFactoryName] = pQualityTestFactory;
	streamlog_out(DEBUG) << "Quality test " << qualityTestFactoryName << " registered !" << std::endl;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::createQualityTest(TiXmlElement *const pXmlElement)
{
	std::string name;
	std::string type;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "name", name));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "type", type));

	DQMQualityTestMap::iterator findIter = m_qualityTestMap.find(name);

	if(m_qualityTestMap.end() != findIter)
		return STATUS_CODE_ALREADY_PRESENT;

	DQMQualityTestFactoryMap::iterator findFactoryIter = m_qualityTestFactoryMap.find(type);

	if(m_qualityTestFactoryMap.end() == findFactoryIter)
			return STATUS_CODE_NOT_FOUND;

	DQMQualityTest *const pQualityTest = findFactoryIter->second->createQualityTest(name);
	pQualityTest->m_type = type;

	try
	{
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->readSettings(TiXmlHandle(pXmlElement)));
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->init());

		if(!m_qualityTestMap.insert(DQMQualityTestMap::value_type(name, pQualityTest)).second)
			throw StatusCodeException(STATUS_CODE_FAILURE);
	}
	catch(const StatusCodeException &exception)
	{
		delete pQualityTest;
		return exception.getStatusCode();
	}

	streamlog_out(DEBUG) << "Quality test: type '" << type << "' , name '" << name << "' created" << std::endl;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::addQualityTest(DQMMonitorElement *pMonitorElement, const std::string &qualityTestName) const
{
	if(NULL == pMonitorElement)
		return STATUS_CODE_INVALID_PTR;

	DQMQualityTest *pQualityTest = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getQualityTest(qualityTestName, pQualityTest));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pMonitorElement->addQualityTest(pQualityTest));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTests(DQMMonitorElement *pMonitorElement)
{
	if(NULL == pMonitorElement)
		return STATUS_CODE_INVALID_PTR;

	return pMonitorElement->runQualityTests();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTest(DQMMonitorElement *pMonitorElement, const std::string &qualityTestName)
{
	if(NULL == pMonitorElement)
		return STATUS_CODE_INVALID_PTR;

	return pMonitorElement->runQualityTest(qualityTestName);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTests()
{
	DQMMonitorElementList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	return this->runQualityTests(monitorElementList);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTests(const DQMMonitorElementList &monitorElementList)
{
	for(DQMMonitorElementList::const_iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->runQualityTests(*iter));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getQualityTest(const std::string &qualityTestName, DQMQualityTest *&pQualityTest) const
{
	pQualityTest = NULL;

	// look for an existing quality test in the map
	DQMQualityTestMap::const_iterator qTestFindIter = m_qualityTestMap.find(qualityTestName);

	if(m_qualityTestMap.end() == qTestFindIter)
		return STATUS_CODE_NOT_FOUND;

	pQualityTest = qTestFindIter->second;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getQualityTestResults(DQMQualityTestResultMap &results) const
{
	DQMMonitorElementList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	for( DQMMonitorElementList::const_iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter )
	{
		DQMMonitorElement *pMonitorElement = *iter;

		const DQMQualityTestResultMap &meResults(pMonitorElement->getQualityTestResults());
		results.insert(meResults.begin(), meResults.end());
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMStorage *DQMMonitorElementManager::getStorage() const
{
	return m_pMonitorElementStorage;
}

} 

