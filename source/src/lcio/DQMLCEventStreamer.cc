  /// \file DQMLCEventStreamer.cc
/*
 *
 * DQMLCEventStreamer.cc source template automatically generated by a class generator
 * Creation date : sam. mars 28 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/lcio/DQMLCEventStreamer.h"
#include "dqm4hep/lcio/DQMLCEvent.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMDataStream.h"
#include "dqm4hep/DQMPlugin.h"

// -- lcio headers
#include "IMPL/LCEventImpl.h"
#include "IMPL/LCGenericObjectImpl.h"
#include "IMPL/LCParametersImpl.h"
#include "IMPL/CalorimeterHitImpl.h"
#include "IMPL/TPCHitImpl.h"
#include "IMPL/RawCalorimeterHitImpl.h"
#include "IMPL/ClusterImpl.h"
#include "IMPL/ParticleIDImpl.h"
#include "IMPL/LCCollectionVec.h"
#include "EVENT/LCIO.h"
#include "EVENT/LCStrVec.h"
#include "EVENT/LCIntVec.h"
#include "EVENT/LCFloatVec.h"
#include "UTIL/LCTOOLS.h"

#include <algorithm>

namespace dqm4hep
{

// declare a streamer plug-in
DQM_PLUGIN_DECL( DQMLCEventStreamer , "LCIOStreamer" )

//-------------------------------------------------------------------------------------------------

DQMLCEventStreamer::DQMLCEventStreamer()
{
	m_lcCollectionStreamerMap[EVENT::LCIO::LCGENERICOBJECT] = new DQMLCCollectionStreamer(EVENT::LCIO::LCGENERICOBJECT, new DQMLCGenericObjectStreamer());
	m_lcCollectionStreamerMap[EVENT::LCIO::CALORIMETERHIT]  = new DQMLCCollectionStreamer(EVENT::LCIO::CALORIMETERHIT,  new DQMCalorimeterHitStreamer());
	m_lcCollectionStreamerMap[EVENT::LCIO::RAWCALORIMETERHIT]  = new DQMLCCollectionStreamer(EVENT::LCIO::RAWCALORIMETERHIT,  new DQMRawCalorimeterHitStreamer());
	m_lcCollectionStreamerMap[EVENT::LCIO::TPCHIT]  = new DQMLCCollectionStreamer(EVENT::LCIO::TPCHIT,  new DQMTPCHitStreamer());
	m_lcCollectionStreamerMap[EVENT::LCIO::CLUSTER]  = new DQMLCCollectionStreamer(EVENT::LCIO::CLUSTER,  new DQMClusterStreamer());
	m_lcCollectionStreamerMap[EVENT::LCIO::PARTICLEID]  = new DQMLCCollectionStreamer(EVENT::LCIO::PARTICLEID,  new DQMParticleIDStreamer());
	m_lcCollectionStreamerMap[EVENT::LCIO::LCFLOATVEC]  = new DQMLCCollectionStreamer(EVENT::LCIO::LCFLOATVEC,  new DQMLCFloatVecStreamer());
	m_lcCollectionStreamerMap[EVENT::LCIO::LCINTVEC]  = new DQMLCCollectionStreamer(EVENT::LCIO::LCINTVEC,  new DQMLCIntVecStreamer());
	m_lcCollectionStreamerMap[EVENT::LCIO::LCSTRVEC]  = new DQMLCCollectionStreamer(EVENT::LCIO::LCSTRVEC,  new DQMLCStrVecStreamer());
}

//-------------------------------------------------------------------------------------------------

DQMLCEventStreamer::~DQMLCEventStreamer()
{
	for(DQMLCCollectionStreamerMap::iterator iter = m_lcCollectionStreamerMap.begin() , endIter = m_lcCollectionStreamerMap.end() ;
			endIter != iter ; ++iter)
		delete iter->second;

	m_lcCollectionStreamerMap.clear();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCEventStreamer::serialize(const DQMEvent *const pEvent, DQMDataStream *const pDataStream)
{
	if(NULL == pEvent)
		return STATUS_CODE_INVALID_PTR;

	EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

	if(NULL == pLCEvent)
		return STATUS_CODE_FAILURE;

	// start filling with event parameters
	dqm_int runNumber = pLCEvent->getRunNumber();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(runNumber));

	dqm_int eventNumber = pLCEvent->getEventNumber();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(eventNumber));

	std::string detectorName = pLCEvent->getDetectorName();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(detectorName));

	dqm_lint timeStamp = pLCEvent->getTimeStamp();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(timeStamp));

	dqm_double weight = pLCEvent->getWeight();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(weight));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_lcParametersStreamer.serialize(&pLCEvent->parameters(), pDataStream));

	const std::vector<std::string> *collectionNames = pLCEvent->getCollectionNames();

	dqm_int nCollections = collectionNames->size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nCollections));

	// write all collections if possible
	for(std::vector<std::string>::const_iterator iter = collectionNames->begin() , endIter = collectionNames->end() ;
			endIter != iter ; ++iter)
	{
		EVENT::LCCollection *pCollection = pLCEvent->getCollection(*iter);
		DQMLCCollectionStreamerMap::const_iterator findIter = m_lcCollectionStreamerMap.find(pCollection->getTypeName());

		if(m_lcCollectionStreamerMap.end() == findIter)
		{
			streamlog_out(WARNING) << "Couldn't serialize collection of type '" << pCollection->getTypeName() << "'. " << std::endl
					  << "The serializer for this collection type is not yet implemented!" << std::endl
					  << "Will skip this collection" << std::endl;;
			continue;
		}

		std::string collectionName = (*iter);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(collectionName));

		std::string collectionType = pCollection->getTypeName();
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(collectionType));

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findIter->second->serialize(pCollection, pDataStream));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCEventStreamer::deserialize(DQMEvent *&pEvent, DQMDataStream *const pDataStream)
{
	pEvent = NULL;

	if(!pDataStream->isValid())
	{
		streamlog_out(WARNING) << "Invalid buffer while deserializing a LCEvent !" << std::endl;
		return STATUS_CODE_NOT_INITIALIZED;
	}

	pEvent = new DQMLCEvent();
	IMPL::LCEventImpl *pTmpLCEvent = new IMPL::LCEventImpl();

	pEvent->setEvent<EVENT::LCEvent>(pTmpLCEvent);

	dqm_int runNumber = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(runNumber));
	pTmpLCEvent->setRunNumber(runNumber);

	dqm_int eventNumber = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(eventNumber));
	pTmpLCEvent->setEventNumber(eventNumber);

	std::string detectorName;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(detectorName));
	pTmpLCEvent->setDetectorName(detectorName);

	dqm_lint timeStamp = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(timeStamp));
	pTmpLCEvent->setTimeStamp(timeStamp);

	dqm_double weight = 0.;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(weight));
	pTmpLCEvent->setWeight(weight);

	EVENT::LCParameters *pLCParameters = &pTmpLCEvent->parameters();

	PROCESS_CODE_IF_AND_RETURN(STATUS_CODE_SUCCESS, !=, m_lcParametersStreamer.deserialize(pLCParameters, pDataStream),
		delete pEvent;
	);

	dqm_int nCollections = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nCollections));

	for(int i=0 ; i<nCollections ; i++)
	{
		EVENT::LCCollection *pCollection = NULL;

		std::string collectionName;
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(collectionName));

		std::string collectionType;
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(collectionType));

		DQMLCCollectionStreamerMap::const_iterator findIter = m_lcCollectionStreamerMap.find(collectionType);

		if(m_lcCollectionStreamerMap.end() == findIter)
		{
			streamlog_out(WARNING) << "Couldn't deserialize collection of type '" << collectionType << "'. " << std::endl
					  << "The serializer for this collection type is not yet implemented!" << std::endl;

			delete pEvent;

			return STATUS_CODE_FAILURE;
		}

		PROCESS_CODE_IF_AND_RETURN(STATUS_CODE_SUCCESS, !=, findIter->second->deserialize(pCollection, pDataStream),
			delete pEvent;
		);

		pTmpLCEvent->addCollection(pCollection, collectionName);
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCEventStreamer::serialize(const DQMEvent *const pEvent, const std::string &subEventIdentifier, DQMDataStream *const pDataStream)
{
	// no sub event queried -> serialize the whole event
	if(subEventIdentifier.empty())
		return this->serialize(pEvent, pDataStream);

	// split the collection names separated by semi columns
	StringVector collectionNames;
	DQM4HEP::tokenize(subEventIdentifier, collectionNames, ":");

	if(collectionNames.empty())
		return STATUS_CODE_FAILURE;

	if(NULL == pEvent)
		return STATUS_CODE_INVALID_PTR;

	EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

	if(NULL == pLCEvent)
		return STATUS_CODE_FAILURE;

	const std::vector<std::string> *pAvailableCollections = pLCEvent->getCollectionNames();

	for(StringVector::iterator iter = collectionNames.begin(), endIter = collectionNames.end() ;
			endIter != iter ; ++iter)
	{
		const std::string &collectionName(*iter);

		if(std::find(pAvailableCollections->begin(), pAvailableCollections->end(), collectionName) == pAvailableCollections->end())
		{
			collectionNames.erase(iter);
			iter--;
		}
	}

	if(collectionNames.empty())
	{
		streamlog_out(ERROR) << "None of the specified collections is available. Couldn't serialize the event !" << std::endl;
		return STATUS_CODE_FAILURE;
	}

	// start filling with event parameters
	dqm_int runNumber = pLCEvent->getRunNumber();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(runNumber));

	dqm_int eventNumber = pLCEvent->getEventNumber();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(eventNumber));

	std::string detectorName = pLCEvent->getDetectorName();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(detectorName));

	dqm_lint timeStamp = pLCEvent->getTimeStamp();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(timeStamp));

	dqm_double weight = pLCEvent->getWeight();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(weight));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_lcParametersStreamer.serialize(&pLCEvent->parameters(), pDataStream));

	dqm_int nCollections = collectionNames.size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nCollections));

	for(std::vector<std::string>::const_iterator iter = collectionNames.begin() , endIter = collectionNames.end() ;
			endIter != iter ; ++iter)
	{
		EVENT::LCCollection *pCollection = pLCEvent->getCollection(*iter);
		DQMLCCollectionStreamerMap::const_iterator findIter = m_lcCollectionStreamerMap.find(pCollection->getTypeName());

		if(m_lcCollectionStreamerMap.end() == findIter)
		{
			streamlog_out(WARNING) << "Couldn't serialize collection of type '" << pCollection->getTypeName() << "'. " << std::endl
					  << "The serializer for this collection type is not yet implemented!" << std::endl
					  << "Will skip this collection" << std::endl;;
			continue;
		}

		std::string collectionName = (*iter);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(collectionName));

		std::string collectionType = pCollection->getTypeName();
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(collectionType));

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findIter->second->serialize(pCollection, pDataStream));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMLCParametersStreamer::serialize(const EVENT::LCParameters *const pLCParameters,
		DQMDataStream *const pDataStream)
{
	// write int keys/values
	EVENT::StringVec keys;
	pLCParameters->getIntKeys(keys);
	dqm_int nKeys = keys.size();

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nKeys));

	for(int i=0 ; i<keys.size() ; i++)
	{
		EVENT::IntVec intVec;
		pLCParameters->getIntVals(keys.at(i), intVec);

		std::string key = keys.at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(key));

		dqm_int nKeyParams = intVec.size();
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nKeyParams));

		for(int j=0 ; j<intVec.size() ; j++)
		{
			dqm_int val = intVec.at(j);
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(val));
		}
	}


	// write float keys/values
	keys.clear();
	pLCParameters->getFloatKeys(keys);
	nKeys = keys.size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nKeys));

	for(int i=0 ; i<keys.size() ; i++)
	{
		EVENT::FloatVec floatVec;
		pLCParameters->getFloatVals(keys.at(i), floatVec);

		std::string key = keys.at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(key));

		dqm_int nKeyParams = floatVec.size();
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nKeyParams));

		for(int j=0 ; j<floatVec.size() ; j++)
		{
			dqm_float val = floatVec.at(j);
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(val));
		}
	}


	// write string keys/values
	keys.clear();
	pLCParameters->getStringKeys(keys);
	nKeys = keys.size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nKeys));

	for(int i=0 ; i<keys.size() ; i++)
	{
		EVENT::StringVec stringVec;
		pLCParameters->getStringVals(keys.at(i), stringVec);

		std::string key = keys.at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(key));

		dqm_int nKeyParams = stringVec.size();
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nKeyParams));

		for(int j=0 ; j<stringVec.size() ; j++)
		{
			std::string val = stringVec.at(j);
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(val));
		}
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCParametersStreamer::deserialize(EVENT::LCParameters *&pLCParameters,
		DQMDataStream *const pDataStream)
{
	dqm_int nInt = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nInt));

	if(nInt != 0)
	{
		for(int i=0 ; i<nInt ; i++)
		{
			std::string key;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(key));

			dqm_int vecSize = 0;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(vecSize));

			EVENT::IntVec intValues;

			for(int j=0 ; j<vecSize ; j++)
			{
				dqm_int value = 0;
				RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
				intValues.push_back(value);
			}

			pLCParameters->setValues(key, intValues);
		}
	}

	dqm_int nFloat = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nFloat));

	if(nFloat != 0)
	{
		for(int i=0 ; i<nFloat ; i++)
		{
			std::string key;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(key));

			dqm_int vecSize = 0;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(vecSize));

			EVENT::FloatVec floatValues;

			for(int j=0 ; j<vecSize ; j++)
			{
				dqm_float value = 0.f;
				RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
				floatValues.push_back(value);
			}

			pLCParameters->setValues(key, floatValues);
		}
	}

	dqm_int nString = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nString));

	if(nString != 0)
	{
		for(int i=0 ; i<nString ; i++)
		{
			std::string key;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(key));

			dqm_int vecSize = 0;
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(vecSize));

			EVENT::StringVec stringValues;

			for(int j=0 ; j<vecSize ; j++)
			{
				std::string value;
				RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
				stringValues.push_back(value);
			}

			pLCParameters->setValues(key, stringValues);
		}
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMLCCollectionStreamer::DQMLCCollectionStreamer(const std::string &collectionType, DQMLCObjectStreamer *pLCObjectStreamer) :
		m_collectionType(collectionType),
		m_pLCObjectStreamer(pLCObjectStreamer)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMLCCollectionStreamer::~DQMLCCollectionStreamer()
{
	delete m_pLCObjectStreamer;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCCollectionStreamer::serialize(const EVENT::LCCollection *const pLCCollection,
		DQMDataStream *const pDataStream)
{
	if(pLCCollection->getTypeName() != m_collectionType)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_int flag = pLCCollection->getFlag();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(flag));

	dqm_bool isTransient = pLCCollection->isTransient();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(isTransient));

	dqm_bool isDefault = pLCCollection->isDefault();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(isDefault));

	dqm_bool isSubset = pLCCollection->isSubset();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(isSubset));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_lcParametersStreamer.serialize(&pLCCollection->getParameters(), pDataStream));

	dqm_int nElements = pLCCollection->getNumberOfElements();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nElements));

	for(int i=0 ; i<pLCCollection->getNumberOfElements() ; i++)
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pLCObjectStreamer->serialize(pLCCollection->getElementAt(i), pDataStream));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCCollectionStreamer::deserialize(EVENT::LCCollection *&pLCCollection,
		DQMDataStream *const pDataStream)
{
	pLCCollection = NULL;

	IMPL::LCCollectionVec *pTmpLCCollection = new IMPL::LCCollectionVec(m_collectionType);

	dqm_int flag = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(flag));
	pTmpLCCollection->setFlag(flag);

	dqm_bool isTransient = false;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(isTransient));
	pTmpLCCollection->setTransient(isTransient);

	dqm_bool isDefault = false;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(isDefault));
	pTmpLCCollection->setDefault(isDefault);

	dqm_bool isSubset = false;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(isSubset));
	pTmpLCCollection->setSubset(isSubset);

	EVENT::LCParameters *pLCParameters = &pTmpLCCollection->parameters();
	PROCESS_CODE_IF_AND_RETURN(STATUS_CODE_SUCCESS, !=, m_lcParametersStreamer.deserialize(pLCParameters, pDataStream),
		delete pTmpLCCollection;
	);

	dqm_int nElements = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nElements));

	for(int i=0 ; i<nElements ; i++)
	{
		EVENT::LCObject *pLCObject = NULL;
		PROCESS_CODE_IF_AND_RETURN(STATUS_CODE_SUCCESS, !=, m_pLCObjectStreamer->deserialize(pLCObject, pDataStream),
			delete pTmpLCCollection;
		);
		pTmpLCCollection->addElement(pLCObject);
	}

	pLCCollection = pTmpLCCollection;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMLCGenericObjectStreamer::serialize(const EVENT::LCObject *const pLCObject,
		DQMDataStream *const pDataStream)
{
	const EVENT::LCGenericObject *const pLCGenericObject = dynamic_cast<const EVENT::LCGenericObject *const>(pLCObject);

	if(NULL == pLCGenericObject)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_bool isFixedSize = pLCGenericObject->isFixedSize();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(isFixedSize));

	dqm_int nInt = pLCGenericObject->getNInt();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nInt));

	dqm_int nFloat = pLCGenericObject->getNFloat();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nFloat));

	dqm_int nDouble = pLCGenericObject->getNDouble();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nDouble));

	for(int i=0 ; i<pLCGenericObject->getNInt() ; i++)
	{
		dqm_int value = pLCGenericObject->getIntVal(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
	}

	for(int i=0 ; i<pLCGenericObject->getNFloat() ; i++)
	{
		dqm_float value = pLCGenericObject->getFloatVal(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
	}

	for(int i=0 ; i<pLCGenericObject->getNDouble() ; i++)
	{
		dqm_double value = pLCGenericObject->getDoubleVal(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCGenericObjectStreamer::deserialize(EVENT::LCObject *&pLCObject,
		DQMDataStream *const pDataStream)
{
	pLCObject = NULL;

	dqm_bool isFixedSize = false;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(isFixedSize));

	dqm_int nInt = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nInt));

	dqm_int nFloat = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nFloat));

	dqm_int nDouble = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nDouble));

	IMPL::LCGenericObjectImpl *pTmpGenericObject =
			isFixedSize ? new IMPL::LCGenericObjectImpl(nInt, nFloat, nDouble) : new IMPL::LCGenericObjectImpl();

	for(dqm_int i=0 ; i<nInt ; i++)
	{
		dqm_int value = 0;
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
		pTmpGenericObject->setIntVal(i, value);
	}

	for(dqm_int i=0 ; i<nFloat ; i++)
	{
		dqm_float value = 0.f;
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
		pTmpGenericObject->setFloatVal(i, value);
	}

	for(dqm_int i=0 ; i<nDouble ; i++)
	{
		dqm_double value = 0;
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
		pTmpGenericObject->setDoubleVal(i, value);
	}

	pLCObject = pTmpGenericObject;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMCalorimeterHitStreamer::serialize(const EVENT::LCObject *const pLCObject,
		DQMDataStream *const pDataStream)
{
	const EVENT::CalorimeterHit *const pCaloHit = dynamic_cast<const EVENT::CalorimeterHit *const>(pLCObject);

	if(NULL == pCaloHit)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_int cellID0 = pCaloHit->getCellID0();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(cellID0));

	dqm_int cellID1 = pCaloHit->getCellID1();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(cellID1));

	dqm_float energy = pCaloHit->getEnergy();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(energy));

	dqm_float energyError = pCaloHit->getEnergyError();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(energyError));

	dqm_float time = pCaloHit->getTime();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(time));

	dqm_int type = pCaloHit->getType();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(type));

	const dqm_float *position = pCaloHit->getPosition();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(position, 3));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMCalorimeterHitStreamer::deserialize(EVENT::LCObject *&pLCObject,
		DQMDataStream *const pDataStream)
{
	pLCObject = NULL;

	IMPL::CalorimeterHitImpl *pTmpCaloHit = new IMPL::CalorimeterHitImpl();

	dqm_int cellID0 = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(cellID0));
	pTmpCaloHit->setCellID0(cellID0);

	dqm_int cellID1 = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(cellID1));
	pTmpCaloHit->setCellID1(cellID1);

	dqm_float energy = 0.f;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(energy));
	pTmpCaloHit->setEnergy(energy);

	dqm_float energyError = 0.f;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(energyError));
	pTmpCaloHit->setEnergyError(energyError);

	dqm_float time = 0.f;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(time));
	pTmpCaloHit->setTime(time);

	dqm_int type = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(type));
	pTmpCaloHit->setType(type);

	dqm_float *pPosition = 0;
	dqm_uint nReceivedSize = 0;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(pPosition, nReceivedSize));

	if(nReceivedSize != 3)
		return STATUS_CODE_FAILURE;

	pTmpCaloHit->setPosition(pPosition);
	delete [] pPosition;

	pLCObject = pTmpCaloHit;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMRawCalorimeterHitStreamer::serialize(const EVENT::LCObject *const pLCObject,
		DQMDataStream *const pDataStream)
{
	const EVENT::RawCalorimeterHit *const pCaloHit = dynamic_cast<const EVENT::RawCalorimeterHit *const>(pLCObject);

	if(NULL == pCaloHit)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_int cellID0 = pCaloHit->getCellID0();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(cellID0));

	dqm_int cellID1 = pCaloHit->getCellID1();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(cellID1));

	dqm_float amplitude = pCaloHit->getAmplitude();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(amplitude));

	dqm_float timeStamp = pCaloHit->getTimeStamp();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(timeStamp));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRawCalorimeterHitStreamer::deserialize(EVENT::LCObject *&pLCObject,
		DQMDataStream *const pDataStream)
{
	pLCObject = 0;

	IMPL::RawCalorimeterHitImpl *pTmpCaloHit = new IMPL::RawCalorimeterHitImpl();

	try
	{
		dqm_int cellID0 = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(cellID0));
		pTmpCaloHit->setCellID0(cellID0);

		dqm_int cellID1 = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(cellID1));
		pTmpCaloHit->setCellID1(cellID1);

		dqm_float amplitude = 0.f;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(amplitude));
		pTmpCaloHit->setAmplitude(amplitude);

		dqm_float timeStamp = 0.f;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(timeStamp));
		pTmpCaloHit->setTimeStamp(timeStamp);
	}
	catch(StatusCodeException &exception)
	{
		delete pTmpCaloHit;
		pTmpCaloHit = 0;
		pLCObject = 0;
	}

	pLCObject = pTmpCaloHit;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMTPCHitStreamer::serialize(const EVENT::LCObject *const pLCObject,
		DQMDataStream *const pDataStream)
{
	const EVENT::TPCHit *const pTPCHit = dynamic_cast<const EVENT::TPCHit *const>(pLCObject);

	if(NULL == pTPCHit)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_int cellID = pTPCHit->getCellID();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(cellID));

	dqm_float time = pTPCHit->getTime();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(time));

	dqm_float charge = pTPCHit->getCharge();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(charge));

	dqm_int quality = pTPCHit->getQuality();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(quality));

	dqm_uint nRawDataWords = pTPCHit->getNRawDataWords();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nRawDataWords));

	for(dqm_uint i=0 ; i<nRawDataWords ; i++)
	{
		dqm_uint rawDataWord = pTPCHit->getRawDataWord(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(rawDataWord));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMTPCHitStreamer::deserialize(EVENT::LCObject *&pLCObject,
		DQMDataStream *const pDataStream)
{
	pLCObject = 0;

	IMPL::TPCHitImpl *pTPCHit = new IMPL::TPCHitImpl();

	try
	{
		dqm_int cellID = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(cellID));
		pTPCHit->setCellID(cellID);

		dqm_int time = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(time));
		pTPCHit->setTime(time);

		dqm_float charge = 0.f;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(charge));
		pTPCHit->setCharge(charge);

		dqm_int quality = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(quality));
		pTPCHit->setQuality(quality);

		dqm_uint nRawDataWords = 0.f;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nRawDataWords));

		int *pRawData = new int[nRawDataWords];

		try
		{
			for(dqm_uint i=0 ; i<nRawDataWords ; i++)
			{
				dqm_int rawDataWord = 0;
				THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(rawDataWord));
				pRawData[i] = rawDataWord;
			}

			pTPCHit->setRawData(pRawData, nRawDataWords);
		}
		catch(const StatusCodeException &exception)
		{
			delete [] pRawData;
			throw StatusCodeException(exception.getStatusCode());
		}
	}
	catch(StatusCodeException &exception)
	{
		delete pTPCHit;
		pTPCHit = 0;
		pLCObject = 0;
	}

	pLCObject = pTPCHit;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMClusterStreamer::serialize(const EVENT::LCObject *const pLCObject, DQMDataStream *const pDataStream)
{
	const EVENT::Cluster *const pCluster = dynamic_cast<const EVENT::Cluster *const>(pLCObject);

	if(NULL == pCluster)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_int type = pCluster->getType();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(type));

	dqm_float energy = pCluster->getEnergy();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(energy));

	dqm_float energyError = pCluster->getEnergyError();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(energyError));

	const dqm_float *pPosition = pCluster->getPosition();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(pPosition, 3));

	dqm_uint nPositionErrors = pCluster->getPositionError().size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nPositionErrors));

	for(dqm_uint i=0 ; i<nPositionErrors ; i++)
	{
		dqm_float positionError = pCluster->getPositionError().at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(positionError));
	}

	dqm_float iTheta = pCluster->getITheta();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(iTheta));

	dqm_float iPhi = pCluster->getIPhi();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(iPhi));

	dqm_uint nDirectionErrors = pCluster->getDirectionError().size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nDirectionErrors));

	for(dqm_uint i=0 ; i<nDirectionErrors ; i++)
	{
		dqm_float directionError = pCluster->getDirectionError().at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(directionError));
	}

	dqm_uint nShapes = pCluster->getShape().size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nShapes));

	for(dqm_uint i=0 ; i<nShapes ; i++)
	{
		dqm_float shape = pCluster->getShape().at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(shape));
	}

	dqm_uint nParticleIDs = pCluster->getParticleIDs().size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nParticleIDs));

	DQMParticleIDStreamer particleIDStreamer;

	for(dqm_uint i=0 ; i<nParticleIDs ; i++)
	{
		EVENT::ParticleID *pParticleID = pCluster->getParticleIDs().at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, particleIDStreamer.serialize(pParticleID, pDataStream));
	}

	dqm_uint nSubdetectorEnergies = pCluster->getSubdetectorEnergies().size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nSubdetectorEnergies));

	for(dqm_uint i=0 ; i<nSubdetectorEnergies ; i++)
	{
		dqm_float subdetectorEnergy = pCluster->getSubdetectorEnergies().at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(subdetectorEnergy));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMClusterStreamer::deserialize(EVENT::LCObject *&pLCObject, DQMDataStream *const pDataStream)
{
	IMPL::ClusterImpl *pCluster = new IMPL::ClusterImpl();

	try
	{
		dqm_int type = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(type));

		std::bitset<32> clusterBitSet(type);

		for(dqm_uint i=0 ; i<clusterBitSet.size() ; i++)
			pCluster->setTypeBit(i, clusterBitSet[i]);

		dqm_float energy = 0.f;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(energy));
		pCluster->setEnergy(energy);

		dqm_float energyError = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(energyError));
		pCluster->setEnergyError(energyError);

		dqm_float *pPosition = 0;
		dqm_uint nPos = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(pPosition, nPos));

		if(nPos != 3)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		pCluster->setPosition(pPosition);
		delete [] pPosition;

		dqm_uint nPositionErrors = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nPositionErrors));

		EVENT::FloatVec positionErrors;

		for(dqm_uint i=0 ; i<nPositionErrors ; i++)
		{
			dqm_float positionError = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(positionError));
			positionErrors.push_back(positionError);
		}

		pCluster->setPositionError(positionErrors);

		dqm_float iTheta = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(iTheta));
		pCluster->setITheta(iTheta);

		dqm_float iPhi = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(iPhi));
		pCluster->setIPhi(iPhi);

		dqm_uint nDirectionErrors = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nDirectionErrors));

		EVENT::FloatVec directionErrors;

		for(dqm_uint i=0 ; i<nDirectionErrors ; i++)
		{
			dqm_float directionError = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(directionError));
			directionErrors.push_back(directionError);
		}

		pCluster->setDirectionError(directionErrors);

		dqm_uint nShapes = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nShapes));

		EVENT::FloatVec shapes;

		for(dqm_uint i=0 ; i<nShapes ; i++)
		{
			dqm_float shape = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(shape));
			shapes.push_back(shape);
		}

		pCluster->setShape(shapes);

		dqm_uint nParticleIDs = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nParticleIDs));

		DQMParticleIDStreamer particleIDStreamer;

		for(dqm_uint i=0 ; i<nParticleIDs ; i++)
		{
			EVENT::LCObject *pParticleID = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, particleIDStreamer.deserialize(pParticleID, pDataStream));
			pCluster->addParticleID(dynamic_cast<EVENT::ParticleID*>(pParticleID));
		}

		dqm_uint nSubdetectorEnergies = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nSubdetectorEnergies));

		for(dqm_uint i=0 ; i<nSubdetectorEnergies ; i++)
		{
			dqm_float subdetectorEnergy = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(subdetectorEnergy));
			pCluster->subdetectorEnergies().push_back(subdetectorEnergy);
		}
	}
	catch(StatusCodeException &exception)
	{
		delete pCluster;
		pCluster = 0;

		return exception.getStatusCode();
	}

	pLCObject = pCluster;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMParticleIDStreamer::serialize(const EVENT::LCObject *const pLCObject, DQMDataStream *const pDataStream)
{
	const EVENT::ParticleID *const pParticleID = dynamic_cast<const EVENT::ParticleID *const>(pLCObject);

	if(NULL == pParticleID)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_int type = pParticleID->getType();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(type));

	dqm_int pdg = pParticleID->getPDG();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(pdg));

	dqm_float likelihood = pParticleID->getLikelihood();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(likelihood));

	dqm_int algorithmType = pParticleID->getAlgorithmType();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(algorithmType));

	dqm_uint nParameters = pParticleID->getParameters().size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nParameters));

	for(dqm_uint i=0 ; i<nParameters ; i++)
	{
		dqm_float parameter = pParticleID->getParameters().at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(parameter));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMParticleIDStreamer::deserialize(EVENT::LCObject *&pLCObject, DQMDataStream *const pDataStream)
{
	pLCObject = 0;
	IMPL::ParticleIDImpl *pParticleID = new IMPL::ParticleIDImpl();

	try
	{
		dqm_int type = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(type));
		pParticleID->setType(type);

		dqm_int pdg = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(pdg));
		pParticleID->setPDG(pdg);

		dqm_float likelihood = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(likelihood));
		pParticleID->setLikelihood(likelihood);

		dqm_int algorithmType = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(algorithmType));
		pParticleID->setAlgorithmType(algorithmType);

		dqm_uint nParameters = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nParameters));

		for(dqm_uint i=0 ; i<nParameters ; i++)
		{
			dqm_float parameter = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(parameter));
			pParticleID->parameters().push_back(parameter);
		}
	}
	catch(StatusCodeException &exception)
	{
		delete pParticleID;
		pParticleID = 0;
		pLCObject = 0;

		return exception.getStatusCode();
	}

	pLCObject = pParticleID;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCFloatVecStreamer::serialize(const EVENT::LCObject *const pLCObject, DQMDataStream *const pDataStream)
{
	const EVENT::LCFloatVec *const pFloatVec = dynamic_cast<const EVENT::LCFloatVec *const>(pLCObject);

	if(NULL == pFloatVec)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_uint nVals = pFloatVec->size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nVals));

	for(dqm_uint i=0 ; i<nVals ; i++)
	{
		dqm_float value = pFloatVec->at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCFloatVecStreamer::deserialize(EVENT::LCObject *&pLCObject, DQMDataStream *const pDataStream)
{
	pLCObject = 0;
	EVENT::LCFloatVec *pFloatVec = new EVENT::LCFloatVec();

	try
	{
		dqm_uint nVals = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nVals));

		for(dqm_uint i=0 ; i<nVals ; i++)
		{
			dqm_float value = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
			pFloatVec->push_back(value);
		}
	}
	catch(StatusCodeException &exception)
	{
		delete pFloatVec;
		pFloatVec = 0;
		pLCObject = 0;

		return exception.getStatusCode();
	}

	pLCObject = pFloatVec;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMLCIntVecStreamer::serialize(const EVENT::LCObject *const pLCObject, DQMDataStream *const pDataStream)
{
	const EVENT::LCIntVec *const pIntVec = dynamic_cast<const EVENT::LCIntVec *const>(pLCObject);

	if(NULL == pIntVec)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_uint nVals = pIntVec->size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nVals));

	for(dqm_uint i=0 ; i<nVals ; i++)
	{
		dqm_int value = pIntVec->at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCIntVecStreamer::deserialize(EVENT::LCObject *&pLCObject, DQMDataStream *const pDataStream)
{
	pLCObject = 0;
	EVENT::LCIntVec *pIntVec = new EVENT::LCIntVec();

	try
	{
		dqm_uint nVals = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nVals));

		for(dqm_uint i=0 ; i<nVals ; i++)
		{
			dqm_int value = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
			pIntVec->push_back(value);
		}
	}
	catch(StatusCodeException &exception)
	{
		delete pIntVec;
		pIntVec = 0;
		pLCObject = 0;

		return exception.getStatusCode();
	}

	pLCObject = pIntVec;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMLCStrVecStreamer::serialize(const EVENT::LCObject *const pLCObject, DQMDataStream *const pDataStream)
{
	const EVENT::LCStrVec *const pStrVec = dynamic_cast<const EVENT::LCStrVec *const>(pLCObject);

	if(NULL == pStrVec)
		return STATUS_CODE_INVALID_PARAMETER;

	dqm_uint nVals = pStrVec->size();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(nVals));

	for(dqm_uint i=0 ; i<nVals ; i++)
	{
		std::string value = pStrVec->at(i);
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(value));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMLCStrVecStreamer::deserialize(EVENT::LCObject *&pLCObject, DQMDataStream *const pDataStream)
{
	pLCObject = 0;
	EVENT::LCStrVec *pStrVec = new EVENT::LCStrVec();

	try
	{
		dqm_uint nVals = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(nVals));

		for(dqm_uint i=0 ; i<nVals ; i++)
		{
			std::string value;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(value));
			pStrVec->push_back(value);
		}
	}
	catch(StatusCodeException &exception)
	{
		delete pStrVec;
		pStrVec = 0;
		pLCObject = 0;

		return exception.getStatusCode();
	}

	pLCObject = pStrVec;

	return STATUS_CODE_SUCCESS;
}

} 

