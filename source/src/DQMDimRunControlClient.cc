  /// \file DQMDimRunControlClient.cc
/*
 *
 * DQMDimRunControlClient.cc source template automatically generated by a class generator
 * Creation date : mer. nov. 12 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMDimRunControlClient.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMRunControl.h"
#include "dqm4hep/DQMPlugin.h"

namespace dqm4hep
{

// run control client plugin declaration
DQM_PLUGIN_DECL( DQMDimRunControlClient , "DimRunControlClient" )

DQMCurrentRunRpcInfo::DQMCurrentRunRpcInfo(char *rpcName, DQMDimRunControlClient *pClient) :
	DimRpcInfo(rpcName, (void *) NULL, 0),
	m_pClient(pClient)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMCurrentRunRpcInfo::rpcInfoHandler()
{
	m_pClient->handleCurrentRunRpcInfo(this);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMDimRunControlClient::DQMDimRunControlClient() :
		DQMRunControlClient(),
		m_isConnected(false),
		m_pStartOfRunInfo(NULL),
		m_pEndOfRunInfo(NULL),
		m_pInBuffer(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMDimRunControlClient::~DQMDimRunControlClient()
{
	if( this->isConnectedToService() )
		this->disconnectFromService();

	if( m_pInBuffer )
		delete m_pInBuffer;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDimRunControlClient::connectToService()
{
	if(isConnectedToService())
		return STATUS_CODE_SUCCESS;

	std::string sorServiceName = "DQM4HEP/RunControl/" + this->getRunControlName() + "/START_OF_RUN";
	std::string eorServiceName = "DQM4HEP/RunControl/" + this->getRunControlName() + "/END_OF_RUN";
	std::string currentRunRpcName = "DQM4HEP/RunControl/" + this->getRunControlName() + "/CURRENT_RUN";

	m_pStartOfRunInfo = new DimUpdatedInfo(sorServiceName.c_str(), (void*) NULL, 0, this);
	m_pEndOfRunInfo = new DimUpdatedInfo(eorServiceName.c_str(), (void*) NULL, 0, this);
	m_pCurrentRunRpcInfo = new DQMCurrentRunRpcInfo( (char *) currentRunRpcName.c_str() , this );

	m_isConnected = true;

	sleep(1);
	int dummy = 0;
	m_pCurrentRunRpcInfo->setData(dummy);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDimRunControlClient::disconnectFromService()
{
	if(!isConnectedToService())
		return STATUS_CODE_SUCCESS;

	delete m_pStartOfRunInfo; m_pStartOfRunInfo = NULL;
	delete m_pEndOfRunInfo; m_pEndOfRunInfo = NULL;
	delete m_pCurrentRunRpcInfo; m_pCurrentRunRpcInfo = NULL;

	m_isConnected = false;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMDimRunControlClient::isConnectedToService() const
{
	return m_isConnected;
}

//-------------------------------------------------------------------------------------------------

void DQMDimRunControlClient::infoHandler()
{
	DimInfo *pCurrentDimInfo = getInfo();

	if(m_pStartOfRunInfo == pCurrentDimInfo)
	{
		if(this->isRunning() || !this->isConnectedToService())
			return;

		dqm_char *pBuffer = static_cast<dqm_char*>(pCurrentDimInfo->getData());
		dqm_uint  bufferSize = pCurrentDimInfo->getSize();

		if(pBuffer == NULL || bufferSize == 0)
			return;

		this->configureInBuffer( pBuffer, bufferSize );

		DQMRun *pRun = new DQMRun();

		try
		{
			if( xdrstream::XDR_SUCCESS != pRun->stream( xdrstream::XDR_READ_STREAM , m_pInBuffer ) )
				throw StatusCodeException(STATUS_CODE_FAILURE);

			if(pRun->getRunNumber() < 0)
				throw StatusCodeException(STATUS_CODE_INVALID_PARAMETER);

			// run is adopted here by the run control. No need to delete
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->startNewRun(pRun));
		}
		catch(StatusCodeException &exception)
		{
			if(pRun)
				delete pRun;
		}
	}
	else if(m_pEndOfRunInfo == pCurrentDimInfo)
	{
		if(!this->isRunning() || !this->isConnectedToService())
			return;

		try
		{
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->endCurrentRun());
		}
		catch(StatusCodeException &exception)
		{
			streamlog_out(WARNING) << "Couldn't stop the run (at stop) : " << exception.toString() << std::endl;
			return;
		}
	}
	else
	{
		streamlog_out(WARNING) << "Unknown info handled by the run control client : " << pCurrentDimInfo->getName() << std::endl;
	}
}

//-------------------------------------------------------------------------------------------------

void DQMDimRunControlClient::handleCurrentRunRpcInfo(DimRpcInfo *pRpcInfo)
{
	if( ! this->isConnectedToService() )
		return;

	DQMRun *pRun = new DQMRun();

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char*>(pRpcInfo->getData());
		dqm_uint  bufferSize = pRpcInfo->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		this->configureInBuffer( pBuffer, bufferSize );

		if( xdrstream::XDR_SUCCESS != pRun->stream( xdrstream::XDR_READ_STREAM , m_pInBuffer ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// run number is invalid, meaning not running
		if(pRun->getRunNumber() <= 0)
			throw StatusCodeException(STATUS_CODE_SUCCESS);

		// run is adopted here by the run control. No need to delete
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->startNewRun(pRun));

		// return avoids run deletion
		return;
	}
	catch(StatusCodeException &exception)
	{
	}

	if(pRun)
		delete pRun;
}

//-------------------------------------------------------------------------------------------------

void DQMDimRunControlClient::configureInBuffer( char *pBuffer , uint32_t bufferSize )
{
	if( ! m_pInBuffer )
		m_pInBuffer = new xdrstream::BufferDevice( pBuffer , bufferSize , false );
	else
		m_pInBuffer->setBuffer( pBuffer , bufferSize , false );

	m_pInBuffer->setOwner( false );
}

} 

