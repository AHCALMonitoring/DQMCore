/*
 *
 * DQMMonitorElementClient.cc source template automatically generated by a class generator
 * Creation date : dim. mai 10 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElementClient.h"
#include "dqm4hep/DQMDataStream.h"
#include "dqm4hep/DQMMessaging.h"

namespace dqm4hep
{

const std::string DQMMonitorElementClient::m_emptyBufferStr = "EMPTY";

DQMMonitorElementClient::DQMMonitorElementClient() :
		m_isConnected(false),
		m_pMonitorElementCollectorInfoRpcInfo(NULL),
		m_pMonitorElementListNameRpcInfo(NULL),
		m_pMonitorElementPacketRpcInfo(NULL),
		m_pHandler(NULL)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementClient::~DQMMonitorElementClient() 
{
	if(isConnectedToService())
		disconnectFromService();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::setCollectorName(const std::string &collectorName)
{
	if(collectorName.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	if(isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	m_collectorName = collectorName;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementClient::getCollectorName() const
{
	return m_collectorName;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::connectToService()
{
	if(isConnectedToService())
		return STATUS_CODE_SUCCESS;

	std::string collectorName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/";
	std::stringstream ss;

	ss << collectorName << "COLLECTOR_INFO";
	m_pMonitorElementCollectorInfoRpcInfo = new DQMMonitorElementCollectorInfoRpcInfo((char*) ss.str().c_str(), this);

	ss.str("");
	ss << collectorName << "MONITOR_ELEMENT_NAME_LIST";
	m_pMonitorElementListNameRpcInfo = new DQMMonitorElementListNameRpcInfo((char*) ss.str().c_str(), this);

	ss.str("");
	ss << collectorName << "MONITOR_ELEMENT_PACKET";
	m_pMonitorElementPacketRpcInfo = new DQMMonitorElementPacketRpcInfo((char*) ss.str().c_str(), this);

	m_isConnected = true;

	if(m_pHandler)
		m_pHandler->handleClientConnection(this);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::disconnectFromService()
{
	if(!isConnectedToService())
		return STATUS_CODE_SUCCESS;

	delete m_pMonitorElementCollectorInfoRpcInfo;
	m_pMonitorElementCollectorInfoRpcInfo = NULL;
	delete m_pMonitorElementListNameRpcInfo;
	m_pMonitorElementListNameRpcInfo = NULL;
	delete m_pMonitorElementPacketRpcInfo;
	m_pMonitorElementPacketRpcInfo = NULL;

	m_isConnected = false;

	if(m_pHandler)
		m_pHandler->handleClientDisconnection(this);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementClient::isConnectedToService() const
{
	return m_isConnected;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::setHandler(Handler *pHandler)
{
	if(isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	m_pHandler = pHandler;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::sendCollectorInfoRequest()
{
	if(!isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	char buf[] = "\0";
	m_pMonitorElementCollectorInfoRpcInfo->setData((void *) &buf[0], 1);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::sendMonitorElementListNameRequest(const DQMMonitorElementListNameRequest &request)
{
	if(!isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	// serialize the list
	DQMDataStream dataStream(10*1024); // should be enough for this request
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, request.serialize(&dataStream));

	// send the request
	m_pMonitorElementListNameRpcInfo->setData((void *) dataStream.getBuffer(), dataStream.getBufferSize());

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::sendMonitorElementPublicationRequest(const DQMMonitorElementRequest &request)
{
	if(!isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	// serialize the request
	DQMDataStream dataStream(1024*1024); // should be enough for this request
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=,  request.serialize(&dataStream));

	// send the request
	m_pMonitorElementPacketRpcInfo->setData((void *) dataStream.getBuffer(), dataStream.getBufferSize());

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollectorInfoRpcInfo::DQMMonitorElementCollectorInfoRpcInfo(char *rpcInfoName, DQMMonitorElementClient *pClient) :
		DimRpcInfo(rpcInfoName, (void*) DQMMonitorElementClient::m_emptyBufferStr.c_str(), DQMMonitorElementClient::m_emptyBufferStr.size()),
		m_pClient(pClient)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollectorInfoRpcInfo::rpcInfoHandler()
{
	try
	{
		if(NULL == m_pClient->m_pHandler)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		dqm_char *pBuffer = static_cast<dqm_char *>(getData());
		dqm_uint bufferSize = getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		if(strcmp(pBuffer, DQMMonitorElementClient::m_emptyBufferStr.c_str()) == 0)
			return;

		DQMDataStream dataStream(512*1024); // should be enough ...
		DQMCollectorInfo collectorInfo;

		// deserialize and call the user call back function
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, dataStream.setBuffer(pBuffer, bufferSize));
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, collectorInfo.deserialize(&dataStream));
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pClient->m_pHandler->receiveCollectorInfo(m_pClient, collectorInfo));
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementListNameRpcInfo::DQMMonitorElementListNameRpcInfo(char *rpcInfoName, DQMMonitorElementClient *pClient) :
		DimRpcInfo(rpcInfoName, (void*) DQMMonitorElementClient::m_emptyBufferStr.c_str(), DQMMonitorElementClient::m_emptyBufferStr.size()),
		m_pClient(pClient)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementListNameRpcInfo::rpcInfoHandler()
{
	try
	{
		if(NULL == m_pClient->m_pHandler)
			throw StatusCodeException(STATUS_CODE_NOT_INITIALIZED);

		dqm_char *pBuffer = static_cast<dqm_char*>(getData());
		dqm_uint bufferSize = getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		if(strcmp(pBuffer, DQMMonitorElementClient::m_emptyBufferStr.c_str()) == 0)
			return;

		DQMDataStream dataStream(5512*1024); // should be enough ...
		DQMMonitorElementInfoList monitorElementInfoList;

		// deserialize and call the user call back function
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, dataStream.setBuffer(pBuffer, bufferSize));
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, monitorElementInfoList.deserialize(&dataStream));
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pClient->m_pHandler->receiveMonitorElementNameList(m_pClient, monitorElementInfoList));
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementPacketRpcInfo::DQMMonitorElementPacketRpcInfo(char *rpcInfoName, DQMMonitorElementClient *pClient) :
		DimRpcInfo(rpcInfoName, (void*) DQMMonitorElementClient::m_emptyBufferStr.c_str(), DQMMonitorElementClient::m_emptyBufferStr.size()),
		m_pClient(pClient)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementPacketRpcInfo::rpcInfoHandler()
{
	try
	{
		if(NULL == m_pClient->m_pHandler)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		dqm_char *pBuffer = static_cast<dqm_char *>(getData());
		dqm_uint bufferSize = getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		if(strcmp(pBuffer, DQMMonitorElementClient::m_emptyBufferStr.c_str()) == 0)
			return;

		DQMDataStream dataStream(512*1024); // should be enough ...
		DQMMonitorElementPublication monitorElementPublication;

		// deserialize and call the user call back function
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, dataStream.setBuffer(pBuffer, bufferSize));
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, monitorElementPublication.deserialize(&dataStream));
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pClient->m_pHandler->receiveMonitorElementPublication(m_pClient, monitorElementPublication));
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}
}

} 

