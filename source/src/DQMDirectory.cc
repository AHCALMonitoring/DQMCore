  /// \file DQMDirectory.cc
/*
 *
 * DQMDirectory.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMDirectory.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMMonitorElement.h"

namespace dqm4hep
{

DQMDirectory::DQMDirectory() :
	m_name(""),
	m_pParentDir(NULL)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMDirectory::DQMDirectory(const std::string &name, DQMDirectory *pParentDir) :
	m_name(name),
	m_pParentDir(pParentDir)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMDirectory::~DQMDirectory()
{
	clear();
}

//-------------------------------------------------------------------------------------------------

void DQMDirectory::ls(bool recursive) const
{
	int depth = 0;
	std::string parentDirName = m_pParentDir == NULL ? "\"\"" : m_pParentDir->m_name;

	streamlog_out(MESSAGE) << "Directory " << m_name << " (parent = " << parentDirName << ") :" << std::endl;

	// print contents first
	for(std::vector<DQMMonitorElement*>::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
			endIter != iter ; ++iter)
	{
		DQMMonitorElement *pMonitorElement = *iter;
		streamlog_out(MESSAGE) << " [ME]  " << pMonitorElement->getName() << std::endl;
	}

	// print sub-directories
	for(std::vector<DQMDirectory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDirectory = *iter;

		if(recursive)
		{
			pDirectory->ls(depth+1);
		}
		else
		{
			streamlog_out(MESSAGE) << " [DIR] " << pDirectory->m_name << std::endl;
		}
	}

	streamlog_out(MESSAGE) << std::endl;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMDirectory::getName() const
{
	return m_name;
}

//-------------------------------------------------------------------------------------------------

DQMDirectory *DQMDirectory::getParentDir() const
{
	return m_pParentDir;
}

//-------------------------------------------------------------------------------------------------

const std::vector<DQMDirectory*> &DQMDirectory::getSubDirList() const
{
	return m_directoryList;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::mkdir(const std::string &dirName)
{
	if(containsDir(dirName))
		return STATUS_CODE_ALREADY_PRESENT;

	DQMDirectory *pNewDirectory = new DQMDirectory(dirName, this);
	m_directoryList.push_back(pNewDirectory);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::containsDir(const std::string &dirName) const
{
	for(std::vector<DQMDirectory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDirectory = *iter;

		if(pDirectory->getName() == dirName)
			return true;
	}

	return false;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::findDir(const std::string &dirName, DQMDirectory *&pDirectory) const
{
	pDirectory = NULL;

	for(std::vector<DQMDirectory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDir = *iter;

		if(pDir->getName() == dirName)
		{
			pDirectory = pDir;
			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::addMonitorElement(DQMMonitorElement *pMonitorElement)
{
	if(NULL == pMonitorElement)
		return STATUS_CODE_INVALID_PTR;

	if(containsMonitorElement(pMonitorElement))
		return STATUS_CODE_ALREADY_PRESENT;

	m_contentsList.push_back(pMonitorElement);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::findMonitorElement(const std::string &name, DQMMonitorElement *&pMonitorElement) const
{
	pMonitorElement = NULL;

	// print contents first
	for(std::vector<DQMMonitorElement*>::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
			endIter != iter ; ++iter)
	{
		DQMMonitorElement *pME = *iter;

		if(pME->getName() == name)
		{
			pMonitorElement = pME;
			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::containsMonitorElement(const DQMMonitorElement *pMonitorElement) const
{
	return containsMonitorElement(pMonitorElement->getName());
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::containsMonitorElement(const std::string &monitorElementName) const
{
	DQMMonitorElement *pMonitorElement = NULL;
	return findMonitorElement(monitorElementName, pMonitorElement) == STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::removeMonitorElement(DQMMonitorElement *pMonitorElement)
{
	return removeMonitorElement(pMonitorElement->getName());
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::removeMonitorElement(const std::string &monitorElementName)
{
	for(std::vector<DQMMonitorElement*>::iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
			endIter != iter ; ++iter)
	{
		DQMMonitorElement *pME = *iter;

		if(pME->getName() == monitorElementName)
		{
			m_contentsList.erase(iter);
			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//-------------------------------------------------------------------------------------------------

const std::vector<DQMMonitorElement*> &DQMDirectory::getMonitorElementList() const
{
	return m_contentsList;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::removeDir(const std::string &dirName, bool deepClean)
{
	for(std::vector<DQMDirectory*>::iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDirectory = *iter;

		if(pDirectory->getName() == dirName)
		{
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->clear(deepClean));
			delete pDirectory;
			m_directoryList.erase(iter);

			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::clear(bool deepClean)
{
	if(deepClean)
	{
		for(std::vector<DQMMonitorElement*>::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
				endIter != iter ; ++iter)
		{
			DQMMonitorElement *pMonitorElement = *iter;
			delete pMonitorElement;
		}
	}

	m_contentsList.clear();



	for(std::vector<DQMDirectory*>::iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDirectory = *iter;
		// clear recursively the sub dir
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->clear(deepClean));
		// delete ptr
		delete pDirectory;
	}

	m_directoryList.clear();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

std::string DQMDirectory::getFullPathName() const
{
	std::string fullPathName = getName();
	const DQMDirectory *pDir = this;

	while(1)
	{
		const DQMDirectory *pParentDir = pDir->getParentDir();

		if(NULL != pParentDir)
		{
			fullPathName = pParentDir->getName() + "/" + fullPathName;
			pDir = pParentDir;
		}
		else
			break;
	}

	return fullPathName;
}

//-------------------------------------------------------------------------------------------------

void DQMDirectory::ls(int depth) const
{
	std::string parentDirName = m_pParentDir == NULL ? "\"\"" : m_pParentDir->m_name;

	streamlog_out(MESSAGE) << std::string(depth*3, ' ') << "Directory " << m_name << " (parent = " << parentDirName << ") :" << std::endl;

	// print contents first
	for(std::vector<DQMMonitorElement*>::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
			endIter != iter ; ++iter)
	{
		DQMMonitorElement *pMonitorElement = *iter;
		streamlog_out(MESSAGE) << std::string(depth*3, ' ') << " [ME]  " << pMonitorElement->getName() << std::endl;
	}

	// print sub dirs
	for(std::vector<DQMDirectory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDirectory = *iter;
		pDirectory->ls(depth+1);
	}
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::isRootDir() const
{
	return (m_pParentDir == NULL);
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::isEmpty() const
{
	return (m_directoryList.empty() && m_contentsList.empty());
}

//-------------------------------------------------------------------------------------------------

} 

