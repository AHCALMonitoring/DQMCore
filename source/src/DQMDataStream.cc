/*
 *
 * DQMDataStream.cc source template automatically generated by a class generator
 * Creation date : mar. janv. 27 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMDataStream.h"
#include "dqm4hep/DQMLogging.h"

// -- std headers
#include <cstring>

namespace dqm4hep
{

DQMDataStream::DQMDataStream(dqm_uint maxBufferSize) :
		m_maxBufferSize(maxBufferSize),
		m_isValid(false),
		m_bufferSize(0)
{
	m_pBuffer = new char[maxBufferSize];
	m_pBufferPtr = m_pBuffer;
	memset(m_pBuffer, 0, maxBufferSize);
}

//-------------------------------------------------------------------------------------------------

DQMDataStream::~DQMDataStream() 
{
	delete [] m_pBuffer;
	m_pBufferPtr = NULL;
}

//-------------------------------------------------------------------------------------------------

void DQMDataStream::reset()
{
	delete [] m_pBuffer;
	m_pBuffer = new char[m_maxBufferSize];
	m_pBufferPtr = m_pBuffer;
	memset(m_pBuffer, 0, m_maxBufferSize);
	m_bufferSize = 0;
	m_isValid = false;
}

//-------------------------------------------------------------------------------------------------

bool DQMDataStream::isValid() const
{
	return (m_bufferSize != 0);
}

//-------------------------------------------------------------------------------------------------

char *DQMDataStream::getBuffer() const
{
	return m_pBuffer;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDataStream::setBuffer(char *pBuffer, dqm_uint size)
{
	if(size > getMaxBufferSize())
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, reallocBuffer(size, false));
	}
	else
	{
		reset();
	}

	memcpy(m_pBuffer, pBuffer, size);
	m_bufferSize = size;
	m_isValid = true;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDataStream::seek(dqm_uint pos)
{
  if(pos > getBufferSize())
    return STATUS_CODE_INVALID_PARAMETER;

  m_pBufferPtr = m_pBuffer + pos;

  return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm_uint DQMDataStream::getMaxBufferSize() const
{
	return m_maxBufferSize;
}

//-------------------------------------------------------------------------------------------------

dqm_uint DQMDataStream::getBufferSize() const
{
	return m_bufferSize;
}

//-------------------------------------------------------------------------------------------------

dqm_uint DQMDataStream::getAvailableSize() const
{
	return getMaxBufferSize() - getBufferSize();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDataStream::reallocBuffer(dqm_uint newSize, bool copyCurrentBuffer)
{
	dqm_uint bufferSize = getBufferSize();
	dqm_uint currentPos = m_pBufferPtr - m_pBuffer;

	// can not shrink the current buffer or allocate 0 size buffer
	if(newSize < bufferSize || 0 == newSize)
		return STATUS_CODE_NOT_ALLOWED;

	char *pNewBuffer = new char[newSize];

	if(NULL != m_pBuffer)
	{
		if(copyCurrentBuffer && 0 != bufferSize)
		{
			memcpy(pNewBuffer, m_pBuffer, bufferSize);
		}
		else
		{
			memset(pNewBuffer, 0, newSize);
		}

		delete [] m_pBuffer;
	}
	else
	{
		memset(pNewBuffer, 0, newSize);
	}

	m_pBuffer = pNewBuffer;
	m_maxBufferSize = newSize;
	seek(currentPos);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDataStream::writeAddress(const void *&pAddress)
{
	dqm_uint size = sizeof(void *);
	dqm_uint availableSize = getMaxBufferSize() - getBufferSize();

	if(availableSize <= size+sizeof(dqm_uint))
	{
		dqm_uint newSize = m_maxBufferSize + 1*1024*1024;

		if(size + sizeof(dqm_uint) > 1*1024*1024)
			newSize = size + sizeof(dqm_uint);

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, reallocBuffer(newSize));
	}

	// get the current buffer ptr
	dqm_uint *pCurrBuff = (dqm_uint *) m_pBufferPtr;

	// write the address in the buffer
	memcpy(m_pBufferPtr, reinterpret_cast<const void*>(&pAddress), size);

	// increment again the buffer
	m_pBufferPtr += size;
	m_bufferSize += size;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDataStream::readAddress(void *&pAddress)
{
	pAddress = NULL;

	dqm_uint *pCurrBuff = (dqm_uint *) m_pBufferPtr;
	dqm_uint size = sizeof(void *);

	char *const pValue = new char[size];

	// read and copy the asked buffer region
	memcpy(pValue, m_pBufferPtr, sizeof(void *));

	// increment the buffer ptr
	m_pBufferPtr += size;

	// read address
	pAddress = *(reinterpret_cast<void **>(pValue));
	delete [] pValue;

	return STATUS_CODE_SUCCESS;
}

} 

