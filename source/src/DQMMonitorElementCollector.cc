/*
 *
 * DQMMonitorElementCollector.cc source template automatically generated by a class generator
 * Creation date : ven. mai 8 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElementCollector.h"
#include "dqm4hep/DQMStorage.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMStatisticsService.h"
#include "dqm4hep/DQMMessaging.h"
#include "dqm4hep/DQMDataStream.h"

/// -- std headers
#include <sys/utsname.h>
#include <unistd.h>
#include <algorithm>

namespace dqm4hep
{

ME_FULL_NAME_COMPARE::ME_FULL_NAME_COMPARE(const DQMPath &fullNameToCompare) :
		m_pathToCompare(fullNameToCompare)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

bool ME_FULL_NAME_COMPARE::operator ()(DQMMonitorElement *pMonitorElement)
{
	if(NULL == pMonitorElement)
		return false;

	DQMPath mePath = pMonitorElement->getPath() + pMonitorElement->getName();

	if(m_pathToCompare == mePath)
		return true;

	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

const std::string DQMMonitorElementCollector::m_emptyBufferStr = "EMPTY";

//-------------------------------------------------------------------------------------------------

DQMCollectorCommandHandler::DQMCollectorCommandHandler(DQMMonitorElementCollector *pCollector) :
		m_pCollector(pCollector)
{
	std::string collectorName = "DQM4HEP/MonitorElementCollector/" + pCollector->m_collectorName + "/";
	std::stringstream ss;

	ss << collectorName << "MONITOR_ELEMENT_PACKET_RECEPTION";
	m_pMEPacketReceptionCommand = new DimCommand((char *)ss.str().c_str(), "C", this);
}

//-------------------------------------------------------------------------------------------------

DQMCollectorCommandHandler::~DQMCollectorCommandHandler()
{
	delete m_pMEPacketReceptionCommand;
}

//-------------------------------------------------------------------------------------------------

void DQMCollectorCommandHandler::commandHandler()
{
	DimCommand *pReceivedCommand = getCommand();

	try
	{
		if(pReceivedCommand == m_pMEPacketReceptionCommand)
		{
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCollector->handleMEPacketReception(pReceivedCommand));
		}
	}
	catch(StatusCodeException &exception)
	{
	}
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollector::DQMMonitorElementCollector() :
		m_collectorName("DEFAULT"),
		m_collectorState(STOPPED_STATE),
		m_pMonitorElementNameListRpc(NULL),
		m_pMonitorElementPacketRpc(NULL),
		m_pMonitorElementCollectorInfoRpc(NULL),
		m_pCommandHandler(NULL),
		m_dataStream(5*1024*1024),
		m_receptionTimerValue(0.f),
		m_pReceptionTimerService(0),
		m_queryTimerValue(0.f),
		m_pQueryTimerService(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollector::~DQMMonitorElementCollector() 
{
	if(isRunning())
		stop();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::setCollectorName(const std::string &collectorName)
{
	if(isRunning())
		return STATUS_CODE_NOT_ALLOWED;

	m_collectorName = collectorName;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementCollector::getCollectorName() const
{
	return m_collectorName;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::start()
{
	if(isRunning())
		return STATUS_CODE_SUCCESS;

	std::string collectorName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/";
	std::stringstream ss;

	ss << collectorName << "MONITOR_ELEMENT_NAME_LIST";
	m_pMonitorElementNameListRpc = new DQMMonitorElementNameListRpc((char *)ss.str().c_str(), this);

	ss.str("");
	ss << collectorName << "MONITOR_ELEMENT_PACKET";
	m_pMonitorElementPacketRpc = new DQMMonitorElementPacketRpc((char *)ss.str().c_str(), this);

	ss.str("");
	ss << collectorName << "COLLECTOR_INFO";
	m_pMonitorElementCollectorInfoRpc = new DQMMonitorElementCollectorInfoRpc((char *)ss.str().c_str(), this);

	ss.str("");
	ss << collectorName << "STATS";
	m_pStatisticsService = new DQMStatisticsService(ss.str());

	m_collectorState = RUNNING_STATE;

	m_pCommandHandler = new DQMCollectorCommandHandler(this);

	m_pReceptionTimerService = new DQMPerformanceService(this->getCollectorName() + "/ME_RECEPTION_TIMER", m_receptionTimerValue);
	m_pQueryTimerService = new DQMPerformanceService(this->getCollectorName() + "/ME_QUERY_TIMER", m_queryTimerValue);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::stop()
{
	if(!isRunning())
		return STATUS_CODE_SUCCESS;

	delete m_pCommandHandler;
	delete m_pMonitorElementNameListRpc;
	delete m_pMonitorElementPacketRpc;
	delete m_pMonitorElementCollectorInfoRpc;
	delete m_pStatisticsService;

	delete m_pReceptionTimerService;
	delete m_pQueryTimerService;

	m_collectorState = STOPPED_STATE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMState DQMMonitorElementCollector::getState() const
{
	return m_collectorState;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementCollector::isRunning() const
{
	return (m_collectorState == RUNNING_STATE);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::reset()
{
	for(DQMMonitorElementListMap::iterator iter = m_monitorElementListMap.begin(), endIter = m_monitorElementListMap.end() ;
			endIter != iter ; ++iter)
	{
		for(DQMMonitorElementList::iterator eltIter = iter->second.begin(), eltEndIter = iter->second.end() ;
				eltEndIter != eltIter ; ++eltIter)
		{
			delete *eltIter;
		}
	}

	m_monitorElementListMap.clear();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::handleMEPacketReception(DimCommand *pCommand)
{
	std::clock_t start = std::clock();

	try
	{
		char *pBuffer = static_cast<char *>(pCommand->getData());
		int bufferSize = pCommand->getSize();

		if(bufferSize == 0 || NULL == pBuffer)
		{
			streamlog_out(WARNING) << "Empty buffer, skipping packet ..." << std::endl;
			throw StatusCodeException(STATUS_CODE_SUCCESS);
		}

		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.setBuffer(pBuffer, bufferSize));

		DQMMonitorElementPublication publication;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, publication.deserialize(&m_dataStream));

		if(publication.m_publication.empty())
		{
			streamlog_out(WARNING) << "Empty publication, skipping packet ..." << std::endl;
			throw StatusCodeException(STATUS_CODE_SUCCESS);
		}

		std::string moduleName = publication.m_publication.begin()->first;

		if(moduleName.empty())
		{
			streamlog_out(WARNING) << "Empty module name, skipping packet ..." << std::endl;
			throw StatusCodeException(STATUS_CODE_FAILURE);
		}

		DQMMonitorElementListMap::iterator findIter2 = m_monitorElementListMap.find(moduleName);

		if(m_monitorElementListMap.end() == findIter2)
		{
			findIter2 = m_monitorElementListMap.insert(DQMMonitorElementListMap::value_type(moduleName, DQMMonitorElementList())).first;
		}

		for(unsigned int i=0 ; i<publication.m_publication.begin()->second.size() ; i++)
		{
			DQMMonitorElement *pMonitorElement = publication.m_publication.begin()->second.at(i);

			DQMPath mePath = pMonitorElement->getPath() + pMonitorElement->getName();

			DQMMonitorElementList::iterator eltIter = std::find_if(findIter2->second.begin(), findIter2->second.end(), ME_FULL_NAME_COMPARE(mePath));

			if(findIter2->second.end() != eltIter)
			{
				delete *eltIter;
				*eltIter = pMonitorElement;
			}
			else
			{
				findIter2->second.push_back(pMonitorElement);
			}

			pMonitorElement->setCollectorName(this->getCollectorName());
		}

		m_pStatisticsService->update(publication.m_publication.begin()->second.size());
	}
	catch(StatusCodeException &exception)
	{
		return exception.getStatusCode();
	}

	m_receptionTimerValue = 1000.0*(std::clock() - start)/CLOCKS_PER_SEC;
	m_pReceptionTimerService->updateService(m_receptionTimerValue);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementNameListRpc::DQMMonitorElementNameListRpc(char *rpcName, DQMMonitorElementCollector *pCollector) :
		DimRpc(rpcName, "C", "C"),
		m_pCollector(pCollector),
		m_dataStream(1024*1024)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNameListRpc::rpcHandler()
{
	try
	{
		if(!m_pCollector->isRunning())
			return;

		dqm_char *pBuffer = static_cast<dqm_char *>(getData());
		dqm_uint bufferSize = getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.setBuffer(pBuffer, bufferSize));

		DQMMonitorElementListNameRequest request;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, request.deserialize(&m_dataStream));

		DQMMonitorElementInfoList infoList;

		for(DQMMonitorElementCollector::DQMMonitorElementListMap::iterator iter = m_pCollector->m_monitorElementListMap.begin(), endIter = m_pCollector->m_monitorElementListMap.end() ;
				endIter != iter ; ++iter)
		{
			std::string moduleName = iter->first;

			std::string moduleNameToLower = moduleName;
			std::string moduleNameToCompareToLower = request.m_moduleName;
			std::transform(moduleNameToLower.begin(), moduleNameToLower.end(), moduleNameToLower.begin(), ::tolower);
			std::transform(moduleNameToCompareToLower.begin(), moduleNameToCompareToLower.end(), moduleNameToCompareToLower.begin(), ::tolower);

			// if module name doesn't contains the asked module name
			if(moduleNameToLower.find(moduleNameToCompareToLower) == std::string::npos && !moduleNameToCompareToLower.empty())
				continue;

			for(DQMMonitorElementList::iterator meIter = iter->second.begin(), meEndIter = iter->second.end() ;
					meEndIter != meIter ; ++meIter)
			{
				DQMMonitorElement *pMonitorElement = *meIter;

				std::string elementNameToLower = pMonitorElement->getName();
				std::string elementNameToCompareToLower = request.m_monitorElementName;
				std::transform(elementNameToLower.begin(), elementNameToLower.end(), elementNameToLower.begin(), ::tolower);
				std::transform(elementNameToCompareToLower.begin(), elementNameToCompareToLower.end(), elementNameToCompareToLower.begin(), ::tolower);

				if(elementNameToLower.find(elementNameToCompareToLower) == std::string::npos && !elementNameToCompareToLower.empty())
					continue;

				if(pMonitorElement->getType() != request.m_monitorElementType && NO_ELEMENT_TYPE != request.m_monitorElementType)
					continue;

				DQMMonitorElementInfo info;
				info.m_moduleName = moduleName;
				info.m_monitorElementFullPath = pMonitorElement->getPath().getPath();
				info.m_monitorElementName = pMonitorElement->getName();
				info.m_monitorElementType = monitorElementTypeToString(pMonitorElement->getType());
				info.m_monitorElementDescription = pMonitorElement->getDescription();

				infoList.push_back(info);
			}
		}

		// serialize the packet
		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, infoList.serialize(&m_dataStream));

		// and set it as data to send back
		setData((void*) m_dataStream.getBuffer(), m_dataStream.getBufferSize());
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementPacketRpc::DQMMonitorElementPacketRpc(char *rpcName, DQMMonitorElementCollector *pCollector) :
		DimRpc(rpcName, "C", "C"),
		m_pCollector(pCollector),
		m_dataStream(5*1024*1024)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementPacketRpc::rpcHandler()
{
	std::clock_t start = std::clock();

	try
	{
		if(!m_pCollector->isRunning())
			return;

		dqm_char *pBuffer = static_cast<dqm_char *>(getData());
		dqm_uint bufferSize = getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.setBuffer(pBuffer, bufferSize));

		DQMMonitorElementRequest request;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, request.deserialize(&m_dataStream));

		DQMMonitorElementPublication monitorElementPublication;

		for(DQMMonitorElementCollector::DQMMonitorElementListMap::iterator iter = m_pCollector->m_monitorElementListMap.begin(), endIter = m_pCollector->m_monitorElementListMap.end() ;
				endIter != iter ; ++iter)
		{
			std::string moduleName = iter->first;

			// find all the monitor elements of this module
			// elements from the request list are suppressed one by one
			while(1)
			{
				std::vector<DQMMonitorElementRequest::ModuleMonitorElementPair>::iterator findRequestIter = std::find_if(request.m_requestList.begin(), request.m_requestList.end(), ME_REQUEST_COMPARE(moduleName));

				if(request.m_requestList.end() == findRequestIter)
					break;

				// look for the monitor element in the list
				DQMMonitorElement *pMonitorElement = NULL;

				// contains path and name
				DQMPath currentMePath(findRequestIter->second);

				for(DQMMonitorElementList::iterator meIter = iter->second.begin(), meEndIter = iter->second.end() ;
						meEndIter != meIter ; ++meIter)
				{

					DQMPath mePath = (*meIter)->getPath() + (*meIter)->getName();

					if(mePath == currentMePath)
					{
						pMonitorElement = *meIter;
						break;
					}
				}

				// if me not found, remove it from the list and skip this element
				if(NULL == pMonitorElement)
				{
					request.m_requestList.erase(findRequestIter);
					continue;
				}

				// add it and remove the iterator
				monitorElementPublication.m_publication[moduleName].push_back(pMonitorElement);
				request.m_requestList.erase(findRequestIter);
			}
		}

		// serialize the packet
		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, monitorElementPublication.serialize(&m_dataStream));

		setData((void*) m_dataStream.getBuffer(), m_dataStream.getBufferSize());
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}

	m_pCollector->m_queryTimerValue = 1000.f*(std::clock() - start)/CLOCKS_PER_SEC;
	m_pCollector->m_pQueryTimerService->updateService(m_pCollector->m_queryTimerValue);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollectorInfoRpc::DQMMonitorElementCollectorInfoRpc(char *rpcName, DQMMonitorElementCollector *pCollector) :
		DimRpc(rpcName, "C", "C"),
		m_pCollector(pCollector),
		m_dataStream(128*1024)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollectorInfoRpc::rpcHandler()
{
	try
	{
		// data stream
		DQMCollectorInfo collectorInfo;

		// uname
		struct utsname unameStruct;
		uname(&unameStruct);
		collectorInfo.m_systemName = unameStruct.sysname;
		collectorInfo.m_nodeName = unameStruct.nodename;
		collectorInfo.m_release = unameStruct.release;
		collectorInfo.m_version = unameStruct.version;
		collectorInfo.m_machine = unameStruct.machine;

		// hostname
		char host[256];
		gethostname(host, 256);
		collectorInfo.m_hostName = host;

		// module name list
		for(DQMMonitorElementCollector::DQMMonitorElementListMap::iterator iter = m_pCollector->m_monitorElementListMap.begin(),
				endIter = m_pCollector->m_monitorElementListMap.end() ; endIter != iter ; ++iter)
			collectorInfo.m_moduleListName.push_back(iter->first);

		// serialize the packet
		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, collectorInfo.serialize(&m_dataStream));

		// get the buffer
		dqm_char *pBuffer = m_dataStream.getBuffer();
		dqm_uint bufferSize = m_dataStream.getBufferSize();

		// and set it as data to send back
		setData((void*) pBuffer, bufferSize);
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}
}

} 

