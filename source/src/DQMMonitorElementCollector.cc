/*
 *
 * DQMMonitorElementCollector.cc source template automatically generated by a class generator
 * Creation date : ven. mai 8 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElementCollector.h"
#include "dqm4hep/DQMStorage.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMStatisticsService.h"
#include "dqm4hep/DQMMessaging.h"
#include "dqm4hep/DQMDataStream.h"

/// -- std headers
#include <sys/utsname.h>
#include <unistd.h>
#include <algorithm>

namespace dqm4hep
{

ModuleMeInfo::ModuleMeInfo()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

ModuleMeInfo::~ModuleMeInfo()
{
	std::cout << "~ModuleMeInfo !!" << std::endl;

	for(MeInfoMap::iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		if(NULL != iter->second.m_pMonitorElement)
			delete iter->second.m_pMonitorElement;
	}
}

//-------------------------------------------------------------------------------------------------

void ModuleMeInfo::setAvailableMeList(const DQMMonitorElementInfoList &meNameList)
{
	m_availableMeList = meNameList;
}

//-------------------------------------------------------------------------------------------------

const DQMMonitorElementInfoList &ModuleMeInfo::getAvailableMeList() const
{
	return m_availableMeList;
}

//-------------------------------------------------------------------------------------------------

bool ModuleMeInfo::updateMonitorElement(DQMMonitorElement *pMonitorElement)
{
	if(NULL == pMonitorElement)
		return false;

	// full name = path + name
	std::string fullName = (pMonitorElement->getPath() + pMonitorElement->getName()).getPath();

	// look for an existing entry
	MeInfoMap::iterator findIter = m_meInfoMap.find(fullName);

	if(findIter == m_meInfoMap.end())
	{
		std::pair<MeInfoMap::iterator, bool> ret = m_meInfoMap.insert(MeInfoMap::value_type(fullName, MeInfo()));

		if(!ret.second)
			return false;

		findIter = ret.first;

		// initialize monitor element pointer
		findIter->second.m_pMonitorElement = NULL;
	}

	// here, findIter is always defined !
	if(NULL != findIter->second.m_pMonitorElement)
	{
		// destroy it !
		delete findIter->second.m_pMonitorElement;
		findIter->second.m_pMonitorElement = NULL;
	}

	// replace it !
	findIter->second.m_pMonitorElement = pMonitorElement;

	return true;
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElement *ModuleMeInfo::getMonitorElement(const std::string &meName, bool partialCompare, bool lowerCaseCompare) const
{
	std::string elementNameToCompare = meName;

	if(lowerCaseCompare)
		std::transform(elementNameToCompare.begin(), elementNameToCompare.end(), elementNameToCompare.begin(), ::tolower);

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		std::string elementName = iter->first;

		if(lowerCaseCompare)
			std::transform(elementName.begin(), elementName.end(), elementName.begin(), ::tolower);

		if(partialCompare)
		{
			if(elementName.find(elementNameToCompare) == std::string::npos)
				continue;
		}
		else
		{
			if(elementName != elementNameToCompare)
				continue;
		}

		return iter->second.m_pMonitorElement;
	}

	return NULL;
}

//-------------------------------------------------------------------------------------------------

StringSet ModuleMeInfo::getSubscribedList() const
{
	StringSet requestedMeList;

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		if( ! iter->second.m_clientList.empty() )
			requestedMeList.insert( iter->first );
	}

	return requestedMeList;
}

//-------------------------------------------------------------------------------------------------

StringSet ModuleMeInfo::getSubscribedList(int clientID) const
{
	StringSet requestedMeList;

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		if( iter->second.m_clientList.find(clientID) != iter->second.m_clientList.end() )
			requestedMeList.insert( iter->first );
	}

	return requestedMeList;
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementList ModuleMeInfo::getSubscribedMeList(int clientID) const
{
	DQMMonitorElementList meList;

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		if( iter->second.m_clientList.find(clientID) != iter->second.m_clientList.end() )
			if( NULL != iter->second.m_pMonitorElement )
				meList.push_back( iter->second.m_pMonitorElement );
	}

	return meList;
}

//-------------------------------------------------------------------------------------------------

std::pair<size_t, bool> ModuleMeInfo::subscribe(int clientID, const std::string &meName)
{
	MeInfoMap::iterator findIter = m_meInfoMap.find(meName);

	// create the entry if not existing
	if(findIter == m_meInfoMap.end())
		findIter = m_meInfoMap.insert(MeInfoMap::value_type(meName, MeInfo())).first;

	// add client and return (new) size of client list
	bool inserted = findIter->second.m_clientList.insert(clientID).second;
	size_t newSize = findIter->second.m_clientList.size();

	return std::pair<size_t, bool>( newSize , inserted );
}

//-------------------------------------------------------------------------------------------------

std::pair<size_t, bool> ModuleMeInfo::unsubscribe(int clientID, const std::string &meName)
{
	MeInfoMap::iterator findIter = m_meInfoMap.find(meName);

	if(findIter == m_meInfoMap.end())
		return std::pair<size_t, bool>( 0 , true );

	// remove client id and return (new) size of client list
	bool erased = ( findIter->second.m_clientList.erase(clientID) != 0 );
	size_t newSize = findIter->second.m_clientList.size();

	return std::pair<size_t, bool>( newSize , erased );
}

//-------------------------------------------------------------------------------------------------

bool ModuleMeInfo::unsubscribe(int clientID)
{
	bool unsubscribeAtLeastToOne = false;

	for(MeInfoMap::iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		if(iter->second.m_clientList.erase(clientID))
			unsubscribeAtLeastToOne = true;
	}

	return unsubscribeAtLeastToOne;
}

//-------------------------------------------------------------------------------------------------

size_t ModuleMeInfo::getNSubscribers(const std::string &meName) const
{
	MeInfoMap::const_iterator findIter = m_meInfoMap.find(meName);
	return ( ( findIter == m_meInfoMap.end() ) ? 0 : findIter->second.m_clientList.size() );
}

//-------------------------------------------------------------------------------------------------

size_t ModuleMeInfo::getNSubscribers() const
{
	std::set<int> clientList;

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		clientList.insert(iter->second.m_clientList.begin(), iter->second.m_clientList.end());
	}

	return clientList.size();
}

//-------------------------------------------------------------------------------------------------

std::set<int> ModuleMeInfo::getSubscribers(const std::string &meName) const
{
	MeInfoMap::const_iterator findIter = m_meInfoMap.find(meName);

	if(findIter != m_meInfoMap.end())
		return findIter->second.m_clientList;

	return std::set<int>();
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** Constructor
 */
ClientInfo::ClientInfo(int clientID) :
		m_clientID(clientID),
		m_updateMode(false),
		m_isModule(false),
		m_moduleName("")
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

ClientInfo::ClientInfo(int clientId, const std::string &moduleName) :
		m_clientID(clientId),
		m_updateMode(false),
		m_isModule(true),
		m_moduleName(moduleName)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

const std::string &ClientInfo::getModuleName() const
{
	return m_moduleName;
}

//-------------------------------------------------------------------------------------------------

bool ClientInfo::isModule() const
{
	return m_isModule;
}

//-------------------------------------------------------------------------------------------------

int ClientInfo::getClientID() const
{
	return m_clientID;
}

//-------------------------------------------------------------------------------------------------

void ClientInfo::setUpdateMode(bool update)
{
	m_updateMode = update;
}

//-------------------------------------------------------------------------------------------------

bool ClientInfo::hasUpdateMode() const
{
	return m_updateMode;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

const std::string DQMMonitorElementCollector::m_emptyBufferStr = "EMPTY";

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollector::DQMMonitorElementCollector() :
		m_collectorName("DEFAULT"),
		m_collectorState(STOPPED_STATE),
		m_pMonitorElementNameListRpc(NULL),
		m_pMonitorElementCollectorInfoRpc(NULL),
		m_dataStream(5*1024*1024)
{
	m_dataStream.write(m_emptyBufferStr);
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollector::~DQMMonitorElementCollector() 
{
	if(isRunning())
		stop();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::setCollectorName(const std::string &collectorName)
{
	if(isRunning())
		return STATUS_CODE_NOT_ALLOWED;

	m_collectorName = collectorName;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementCollector::getCollectorName() const
{
	return m_collectorName;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::start()
{
	if(isRunning())
		return STATUS_CODE_SUCCESS;

	std::string baseName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/";
	std::stringstream ss;

	ss << baseName << "MONITOR_ELEMENT_NAME_LIST_RPC";
	m_pMonitorElementNameListRpc = new DQMMonitorElementNameListRpc((char *)ss.str().c_str(), this);

	ss.str("");
	ss << baseName << "COLLECTOR_INFO_RPC";
	m_pMonitorElementCollectorInfoRpc = new DQMMonitorElementCollectorInfoRpc((char *)ss.str().c_str(), this);

	// from modules
	ss << baseName << "COLLECT_ME_CMD";
	m_pCollectMeCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	// from clients
	ss.str("");
	ss << baseName << "AVAILABLE_ME_CMD";
	m_pAvailableMeListCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "QUERY_ME_CMD";
	m_pMeQueryCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "SET_UPDATE_MODE_CMD";
	m_pSetUpdateModeCommand = new DimCommand((char *)ss.str().c_str(), "I", this);

	ss.str("");
	ss << baseName << "SUBSCRIBE_CMD";
	m_pSubscribeCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "UNSUBSCRIBE_CMD";
	m_pUnsubscribeCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "SET_SUBSCRIPTION_CMD";
	m_pSetSubscriptionCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "STATS";
	m_pStatisticsService = new DQMStatisticsService(ss.str());

	ss.str("");
	ss << baseName << "ME_UPDATE_SVC";
	m_pMeUpdateService = new DimService((char *)ss.str().c_str(), "C",
			(void*) m_dataStream.getBuffer(), m_dataStream.getBufferSize());

	ss.str("");
	ss << baseName << "NOTIFY_WATCHED_ME_SVC";
	m_pNotifyWatchedMeService = new DimService((char *)ss.str().c_str(), "C",
			(void*) m_dataStream.getBuffer(), m_dataStream.getBufferSize());

	m_collectorState = RUNNING_STATE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::stop()
{
	if(!isRunning())
		return STATUS_CODE_SUCCESS;

	delete m_pCollectMeCommand;
	delete m_pAvailableMeListCommand;
	delete m_pMeQueryCommand;
	delete m_pSetUpdateModeCommand;
	delete m_pSubscribeCommand;
	delete m_pUnsubscribeCommand;
	delete m_pSetSubscriptionCommand;

	delete m_pMonitorElementNameListRpc;
	delete m_pMonitorElementCollectorInfoRpc;
	delete m_pStatisticsService;
	delete m_pMeUpdateService;
	delete m_pNotifyWatchedMeService;

	m_collectorState = STOPPED_STATE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMState DQMMonitorElementCollector::getState() const
{
	return m_collectorState;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementCollector::isRunning() const
{
	return (m_collectorState == RUNNING_STATE);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::updateClients(const ClientUpdateMap &clientUpdateMap)
{
	for(ClientUpdateMap::const_iterator iter = clientUpdateMap.begin(), endIter = clientUpdateMap.end() ;
			endIter != iter ; ++iter)
	{
		ClientMap::iterator clientIter = m_clientMap.find(iter->first);

		if(clientIter == m_clientMap.end())
			continue;

		if(!clientIter->second.hasUpdateMode())
			continue;

		this->sendMeUpdate(clientIter->first);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::commandHandler()
{
	DimCommand *pReceivedCommand = getCommand();

	// from modules
	if(pReceivedCommand == m_pCollectMeCommand)
	{
		this->handleMeCollectUpdate(pReceivedCommand);
	}
	else if(pReceivedCommand == m_pAvailableMeListCommand)
	{
		this->handleAvailableListUpdate(pReceivedCommand);
	}
	// from client side
	else if(pReceivedCommand == m_pMeQueryCommand)
	{
		this->sendMeUpdate(getClientId());
	}
	else if(pReceivedCommand == m_pSetUpdateModeCommand)
	{
		this->handleClientUpdateMode(getClientId(), static_cast<bool>(pReceivedCommand->getInt()));
	}
	else if(pReceivedCommand == m_pSubscribeCommand)
	{
		this->handleClientSubscription(getClientId(), pReceivedCommand);
	}
	else if(pReceivedCommand == m_pUnsubscribeCommand)
	{
		this->handleClientUnsubscription(getClientId(), pReceivedCommand);
	}
	else if(pReceivedCommand == m_pSetSubscriptionCommand)
	{
		this->handleClientRequestList(getClientId(), pReceivedCommand);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::clientExitHandler()
{
	int clientId = getClientId();

	// need to look for both module client and me client


}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleMeCollectUpdate(DimCommand *pCommand)
{
	try
	{
		char *pBuffer = static_cast<char *>(pCommand->getData());
		int bufferSize = pCommand->getSize();

		if(bufferSize == 0 || NULL == pBuffer)
		{
			streamlog_out(WARNING) << "Empty buffer, skipping packet ..." << std::endl;
			throw StatusCodeException(STATUS_CODE_SUCCESS);
		}

		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.setBuffer(pBuffer, bufferSize));

		DQMMonitorElementPublication publication;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, publication.deserialize(&m_dataStream));

		if(publication.m_publication.empty())
		{
			streamlog_out(WARNING) << "Empty publication, skipping packet ..." << std::endl;
			throw StatusCodeException(STATUS_CODE_SUCCESS);
		}

		int nElements = 0;
		ClientUpdateMap clientUpdateMap;

		// update the monitor element with ones received !
		// build the monitor element list to update for each client
		for(DQMMonitorElementPublication::PublicationMap::iterator iter = publication.m_publication.begin(),
				endIter = publication.m_publication.end() ; endIter != iter ; ++iter)
		{
			ModuleMeInfoMap::iterator findIter = m_moduleMeInfoMap.find(iter->first);

			// if module not found, clean the monitor elements related to this module
			if(findIter == m_moduleMeInfoMap.end())
			{
				for(DQMMonitorElementList::iterator meIter = iter->second.begin(), meEndIter = iter->second.end() ;
						meEndIter != meIter ; ++meIter)
					delete *meIter;

				continue;
			}

			// update monitor elements !
			for(DQMMonitorElementList::iterator meIter = iter->second.begin(), meEndIter = iter->second.end() ;
									meEndIter != meIter ; ++meIter)
			{
				bool updated = findIter->second.updateMonitorElement(*meIter);

				if(!updated)
					delete *meIter;

				nElements++;

				(*meIter)->setCollectorName(this->getCollectorName());

				// get the client ids that have subscribed to these elements
				std::string meFullName = ( (*meIter)->getPath() + (*meIter)->getName() ).getPath();
				std::set<int> clientIdSet = findIter->second.getSubscribers(meFullName);

				// add the monitor element entry into the update map
				for(std::set<int>::iterator cliIter = clientIdSet.begin(), cliEndIter = clientIdSet.end() ;
						cliEndIter != cliIter ; ++cliIter)
				{
					clientUpdateMap[*cliIter].insert(*meIter);
				}
			}
		}

		m_pStatisticsService->update(nElements);

		this->updateClients(clientUpdateMap);
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(WARNING) << "Exception caught : " << exception.toString() << std::endl;
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleAvailableListUpdate(DimCommand *pCommand)
{
	if(!this->isRunning())
		return;

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
		dqm_uint bufferSize = pCommand->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.setBuffer(pBuffer, bufferSize));

		// read the buffer
		std::string moduleName;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(moduleName));

		if(moduleName.empty())
			return;

		DQMMonitorElementInfoList availableMeList;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, availableMeList.deserialize(&m_dataStream));

		// register client, even if maybe already registered
		this->registerClient(getClientId(), moduleName);

		// look for module entry to update
		ModuleMeInfoMap::iterator findIter = m_moduleMeInfoMap.find(moduleName);

		// if not found, add the entry
		if(findIter == m_moduleMeInfoMap.end())
			findIter = m_moduleMeInfoMap.insert(ModuleMeInfoMap::value_type(moduleName, ModuleMeInfo())).first;

		// update the entry
		findIter->second.setAvailableMeList(availableMeList);
	}
	catch(const StatusCodeException &exception)
	{
		streamlog_out(WARNING) << "Exception caught : " << exception.toString() << std::endl;
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleClientRegistration(int clientId, bool shouldRegister)
{
	ClientMap::iterator findIter = m_clientMap.find(clientId);

	if(shouldRegister)
	{
		if(findIter == m_clientMap.end())
			m_clientMap.insert(ClientMap::value_type(clientId, ClientInfo(clientId)));
	}
	else
	{
		if(findIter != m_clientMap.end())
		{
			// first, we need to unsubscribe to all elements for all modules
			for(ModuleMeInfoMap::iterator iter = m_moduleMeInfoMap.begin(), endIter = m_moduleMeInfoMap.end() ;
					endIter != iter ; ++iter)
			{
				iter->second.unsubscribe(clientId);
			}

			// remove client from map
			m_clientMap.erase(findIter);
		}
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleClientUpdateMode(int clientId, bool updateMode)
{
	ClientMap::iterator findIter = m_clientMap.find(clientId);

	if(findIter != m_clientMap.end())
	{
		if( ! findIter->second.hasUpdateMode() && updateMode)
			this->sendMeUpdate(clientId);

		findIter->second.setUpdateMode(updateMode);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleClientRequestList(int clientID, DimCommand *pCommand)
{
	if(!this->isRunning())
		return;

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
		dqm_uint bufferSize = pCommand->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.setBuffer(pBuffer, bufferSize));

		dqm_uint nModules = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(nModules));

		for(dqm_uint m=0 ; m<nModules ; m++)
		{
			std::string moduleName;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(moduleName));

			dqm_uint nElements = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(nElements));

			// look for module entry to update
			ModuleMeInfoMap::iterator findIter = m_moduleMeInfoMap.find(moduleName);
			bool updateRequestListService = false;

			// first unsubscribe all elements
			if(findIter != m_moduleMeInfoMap.end())
			{
				if(findIter->second.unsubscribe(clientID))
					updateRequestListService = true;
			}

			// subscribe to elements one by one
			for(dqm_uint e=0 ; e<nElements ; e++)
			{
				std::string meName;
				THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(meName));

				if(findIter != m_moduleMeInfoMap.end())
					findIter->second.subscribe(clientID, meName);
			}

			// watched element list has changed ! Notify module !
			this->notifyWatchedMe(moduleName);
		}
	}
	catch(const StatusCodeException &exception)
	{
		streamlog_out(WARNING) << "Exception caught : " << exception.toString() << std::endl;
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleClientSubscription(int clientID, DimCommand *pCommand)
{
	if(!this->isRunning())
		return;

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
		dqm_uint bufferSize = pCommand->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.setBuffer(pBuffer, bufferSize));

		dqm_uint nModules = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(nModules));

		for(dqm_uint m=0 ; m<nModules ; m++)
		{
			std::string moduleName;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(moduleName));

			dqm_uint nElements = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(nElements));

			// look for module entry to update
			ModuleMeInfoMap::iterator findIter = m_moduleMeInfoMap.find(moduleName);
			bool updateRequestListService = false;

			// subscribe to elements one by one
			for(dqm_uint e=0 ; e<nElements ; e++)
			{
				std::string meName;
				THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(meName));

				if(findIter != m_moduleMeInfoMap.end())
					findIter->second.subscribe(clientID, meName);
			}
		}
	}
	catch(const StatusCodeException &exception)
	{
		streamlog_out(WARNING) << "Exception caught : " << exception.toString() << std::endl;
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleClientUnsubscription(int clientID, DimCommand *pCommand)
{
	if(!this->isRunning())
		return;

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
		dqm_uint bufferSize = pCommand->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.setBuffer(pBuffer, bufferSize));

		dqm_uint nModules = 0;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(nModules));

		for(dqm_uint m=0 ; m<nModules ; m++)
		{
			std::string moduleName;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(moduleName));

			dqm_uint nElements = 0;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(nElements));

			// look for module entry to update
			ModuleMeInfoMap::iterator findIter = m_moduleMeInfoMap.find(moduleName);
			bool updateRequestListService = false;

			// subscribe to elements one by one
			for(dqm_uint e=0 ; e<nElements ; e++)
			{
				std::string meName;
				THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.read(meName));

				if(findIter != m_moduleMeInfoMap.end())
					findIter->second.unsubscribe(clientID, meName);
			}
		}
	}
	catch(const StatusCodeException &exception)
	{
		streamlog_out(WARNING) << "Exception caught : " << exception.toString() << std::endl;
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::sendMeUpdate(int clientID)
{
	if(!this->isRunning())
		return;

	DQMMonitorElementPublication monitorElementPublication;

	for(ModuleMeInfoMap::const_iterator iter = m_moduleMeInfoMap.begin(), endIter = m_moduleMeInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		std::string moduleName = iter->first;

		DQMMonitorElementList subscribedMeList = iter->second.getSubscribedMeList(clientID);

		if(subscribedMeList.empty())
			continue;

		monitorElementPublication.m_publication.insert(DQMMonitorElementPublication::PublicationMap::value_type(moduleName, subscribedMeList));
	}

	if(monitorElementPublication.m_publication.empty())
		return;

	m_dataStream.reset();
	StatusCode statusCode = monitorElementPublication.serialize(&m_dataStream);

	if(statusCode != STATUS_CODE_SUCCESS)
	{
		m_dataStream.reset();
		return;
	}

	int clientIds[2];
	clientIds[0] = clientID;
	clientIds[1] = 0;

	m_pMeUpdateService->selectiveUpdateService((void *) m_dataStream.getBuffer(), m_dataStream.getBufferSize() , &clientIds[0]);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::notifyWatchedMe(const std::string &moduleName)
{
	int clientId = this->getModuleClientID(moduleName);

	if(0 == clientId)
		return;

	ModuleMeInfoMap::iterator moduleFindIter = m_moduleMeInfoMap.find(moduleName);

	if(moduleFindIter == m_moduleMeInfoMap.end())
		return;

	StringSet watchedMeList = moduleFindIter->second.getSubscribedList();

	// no element watched ?
	if(watchedMeList.empty())
		return;

	m_dataStream.reset();

	for(StringSet::iterator iter = watchedMeList.begin(), endIter = watchedMeList.end() ;
			endIter != iter ; ++iter)
	{
		if(STATUS_CODE_SUCCESS != m_dataStream.write(*iter))
		{
			m_dataStream.reset();
			return;
		}
	}

	if(m_dataStream.getBufferSize() == 0)
		return;

	int clientIds[2];
	clientIds[0] = clientId;
	clientIds[1] = 0;

	m_pNotifyWatchedMeService->selectiveUpdateService( (void *) m_dataStream.getBuffer(), m_dataStream.getBufferSize(), &clientIds[0] );
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::registerClient(int clientId)
{
	ClientMap::iterator findIter = m_clientMap.find(clientId);

	if(findIter != m_clientMap.end())
		return;

	// just insert a new client
	m_clientMap.insert( ClientMap::value_type( clientId, ClientInfo(clientId) ) );
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::registerClient(int clientId, const std::string moduleName)
{
	ClientMap::iterator findIter = m_clientMap.find(clientId);

	if(findIter != m_clientMap.end())
		return;

	// insert a new client
	m_clientMap.insert( ClientMap::value_type( clientId, ClientInfo(clientId, moduleName) ) );

	// create monitor element storage
	m_moduleMeInfoMap.insert( ModuleMeInfoMap::value_type( moduleName, ModuleMeInfo() ) );
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::deregisterClient(int clientId)
{
	ClientMap::iterator findIter = m_clientMap.find(clientId);

	if(findIter == m_clientMap.end())
		return;

	// module client case
	if(findIter->second.isModule())
	{
		std::string moduleName = findIter->second.getModuleName();

		ModuleMeInfoMap::iterator moduleFindIter = m_moduleMeInfoMap.find(moduleName);

		if(moduleFindIter != m_moduleMeInfoMap.end())
			m_moduleMeInfoMap.erase(moduleFindIter);
	}
	// monitor element client case
	else
	{
		// unsubscribe to all element that the client subscribed
		// this will update the list of watched monitor elements
		// We then have to notify modules that watched elements are not the same
		for(ModuleMeInfoMap::iterator iter = m_moduleMeInfoMap.begin(), endIter = m_moduleMeInfoMap.end() ;
				endIter != iter ; ++iter)
		{
			// this returns if at least one element has been removed
			// from the watched list. Use it to trigger update if necessary
			bool updateService = iter->second.unsubscribe(clientId);

			if(updateService)
				this->notifyWatchedMe(iter->first);
		}
	}

	// finally remove the client from the map
	m_clientMap.erase(findIter);

	return;
}

//-------------------------------------------------------------------------------------------------

int DQMMonitorElementCollector::getModuleClientID(const std::string &moduleName) const
{
	for(ClientMap::const_iterator iter = m_clientMap.begin(), endIter = m_clientMap.end() ;
			endIter != iter ; ++iter)
	{
		if( ! iter->second.isModule() )
			continue;

		if( iter->second.getModuleName() == moduleName )
			return iter->first;
	}

	return 0;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementNameListRpc::DQMMonitorElementNameListRpc(char *rpcName, DQMMonitorElementCollector *pCollector) :
		DimRpc(rpcName, "C", "C"),
		m_pCollector(pCollector),
		m_dataStream(1024*1024)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNameListRpc::rpcHandler()
{
	try
	{
		if(!m_pCollector->isRunning())
			return;

		dqm_char *pBuffer = static_cast<dqm_char *>(getData());
		dqm_uint bufferSize = getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_dataStream.setBuffer(pBuffer, bufferSize));

		DQMMonitorElementListNameRequest request;
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, request.deserialize(&m_dataStream));

		// transform module name to lower for easier comparison
		std::transform(request.m_moduleName.begin(), request.m_moduleName.end(), request.m_moduleName.begin(), ::tolower);
		std::transform(request.m_monitorElementName.begin(), request.m_monitorElementName.end(), request.m_monitorElementName.begin(), ::tolower);

		DQMMonitorElementInfoList infoList;

		// loop over available contents and apply some filter to anwser the client query
		for(DQMMonitorElementCollector::ModuleMeInfoMap::const_iterator iter = m_pCollector->m_moduleMeInfoMap.begin(),
				endIter = m_pCollector->m_moduleMeInfoMap.end() ; endIter != iter ; ++iter)
		{
			std::string moduleName = iter->first;
			std::transform(moduleName.begin(), moduleName.end(), moduleName.begin(), ::tolower);

			// partial and lower case compare of module name
			if(moduleName.find(request.m_moduleName) == std::string::npos && !request.m_moduleName.empty())
				continue;

			const std::vector<DQMMonitorElementInfo> &availableMeList = iter->second.getAvailableMeList();

			for(std::vector<DQMMonitorElementInfo>::const_iterator meIter = availableMeList.begin(), meEndIter = availableMeList.end() ;
					meEndIter != meIter ; ++meIter)
			{
				std::string meName = meIter->m_monitorElementName;
				std::transform(meName.begin(), meName.end(), meName.begin(), ::tolower);

				std::string path = meIter->m_monitorElementFullPath;
				std::transform(path.begin(), path.end(), path.begin(), ::tolower);

				// partial and lower case compare of me name
				if(meName.find(request.m_monitorElementName) == std::string::npos && !request.m_monitorElementName.empty())
					continue;

				// partial and lower case compare of path using me name
				if(path.find(request.m_monitorElementName) == std::string::npos && !request.m_monitorElementName.empty())
					continue;

				// compare me type
				if(meIter->m_monitorElementType != monitorElementTypeToString(request.m_monitorElementType) && NO_ELEMENT_TYPE != request.m_monitorElementType)
					continue;

				infoList.push_back(*meIter);
			}
		}

		// serialize the packet
		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, infoList.serialize(&m_dataStream));

		// and set it as data to send back
		setData((void*) m_dataStream.getBuffer(), m_dataStream.getBufferSize());
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollectorInfoRpc::DQMMonitorElementCollectorInfoRpc(char *rpcName, DQMMonitorElementCollector *pCollector) :
		DimRpc(rpcName, "C", "C"),
		m_pCollector(pCollector),
		m_dataStream(128*1024)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollectorInfoRpc::rpcHandler()
{
	try
	{
		DQMCollectorInfo collectorInfo;

		// uname
		struct utsname unameStruct;
		uname(&unameStruct);
		collectorInfo.m_systemName = unameStruct.sysname;
		collectorInfo.m_nodeName = unameStruct.nodename;
		collectorInfo.m_release = unameStruct.release;
		collectorInfo.m_version = unameStruct.version;
		collectorInfo.m_machine = unameStruct.machine;

		// hostname
		char host[256];
		gethostname(host, 256);
		collectorInfo.m_hostName = host;

		// module name list
		for(DQMMonitorElementCollector::ModuleMeInfoMap::iterator iter = m_pCollector->m_moduleMeInfoMap.begin(),
				endIter = m_pCollector->m_moduleMeInfoMap.end() ; endIter != iter ; ++iter)
			collectorInfo.m_moduleListName.push_back(iter->first);

		// serialize the packet
		m_dataStream.reset();
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, collectorInfo.serialize(&m_dataStream));

		// get the buffer
		dqm_char *pBuffer = m_dataStream.getBuffer();
		dqm_uint bufferSize = m_dataStream.getBufferSize();

		// and set it as data to send back
		setData((void*) pBuffer, bufferSize);
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}
}

} 

