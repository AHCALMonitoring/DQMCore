/*
 *
 * DQMPluginManager.h header template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMPLUGINMANAGER_H
#define DQMPLUGINMANAGER_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/DQMSingleton.h"
#include "dqm4hep/DQMPlugin.h"

namespace dqm4hep
{

class DQMPlugin;

/** DQMPluginManager class.
 *  Responsible for loading shared libraries
 *  that contains DQMPlugin instances
 */ 
class DQMPluginManager : public DQMSingleton<DQMPluginManager>
{
	friend class DQMSingleton<DQMPluginManager>;
	friend class DQMPlugin;

	typedef std::map<const std::string, DQMPlugin*> DQMPluginMap;

public:
	/** Load shared libraries from the environment variable DQM4HEP_PLUGIN_DLL
	 */
	StatusCode loadLibraries();

	/** Load the shared libraries
	 */
	StatusCode loadLibraries( const StringVector &libraryNameList );

	/** Load the shared library
	 */
	StatusCode loadLibrary( const std::string &libraryName );

	/** Get the plug-in by name
	 */
	DQMPlugin *getPlugin( const std::string &pluginName ) const;

	/** Get the plug-in clone. A new plug-in instance is allocated and returned
	 *  to the user. Ownership of the plug-in transfered to the caller.
	 */
	template <typename T>
	T *createPluginClass( const std::string &pluginName ) const;

	/** Whether the plug-in is registered within the plug-in manager
	 */
	bool isPluginRegistered( const std::string &pluginName ) const;

	/** Get the plug-in name list
	 */
	StringVector getPluginNameList() const;

private:
	/** Constructor
	 */
	DQMPluginManager();

	/** Destructor
	 */
	~DQMPluginManager();

	/** Register the plug-in. Only available by plug-ins themselves
	 */
	StatusCode registerPlugin( DQMPlugin *pPlugin );

private:
	DQMPluginMap              m_pluginMap;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

template <typename T>
inline T *DQMPluginManager::createPluginClass( const std::string &pluginName ) const
{
	DQMPlugin *pPlugin = this->getPlugin( pluginName );

	if(!pPlugin)
		return 0;

	DQMPlugin *pClass = pPlugin->create();

	if(NULL == pClass)
		return 0;

	return dynamic_cast<T *>(pClass);
}

} 

#endif  //  DQMPLUGINMANAGER_H
