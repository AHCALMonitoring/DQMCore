/*
 *
 * DQMPluginManager.h header template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMPLUGINMANAGER_H
#define DQMPLUGINMANAGER_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/DQMSingleton.h"
#include "dqm4hep/DQMPlugin.h"

namespace dqm4hep
{

class DQMPlugin;

/** DQMPluginManager class.
 *  Responsible for loading shared libraries
 *  that contains DQMPlugin instances
 */ 
class DQMPluginManager : public DQMSingleton<DQMPluginManager>
{
	friend class DQMSingleton<DQMPluginManager>;
	friend class DQMPlugin;

	typedef std::map<const std::string, DQMPlugin*> DQMPluginMap;

public:
	/** Load shared libraries from the environment variable DQM4HEP_PLUGIN_DLL
	 */
	StatusCode loadLibraries();

	/** Load the shared libraries
	 */
	StatusCode loadLibraries( const StringVector &libraryNameList );

	/** Load the shared library
	 */
	StatusCode loadLibrary( const std::string &libraryName );



	/** Get the plug-in by name
	 */
	StatusCode getPlugin( const std::string &pluginName, DQMPlugin *&pPlugin ) const;

	/** Get the plug-in clone. A new plug-in instance is allocated and returned
	 *  to the user. Ownership of the plug-in transfered to the caller.
	 */
	StatusCode getPluginClone( const std::string &pluginName, DQMPlugin *&pPlugin ) const;

	/** Find and returns the plug-in by name.
	 *  The plug-in is removed from the registered plug-ins
	 */
	StatusCode takePlugin( const std::string &pluginName, DQMPlugin *&pPlugin );

	/** Whether the plug-in is registered within the plug-in manager
	 */
	bool isPluginRegistered( const std::string &pluginName ) const;



	/** Get the plug-in by name.
	 *  The found plug-in is casted in the asked type
	 */
	template <typename T>
	StatusCode getCastedPlugin( const std::string &pluginName, T *&pPlugin ) const;

	/** Get the plug-in clone. A new plug-in instance is allocated and returned
	 *  to the user. Ownership of the plug-in transfered to the caller.
	 *  The found plug-in is casted in the asked type
	 */
	template <typename T>
	StatusCode getCastedPluginClone( const std::string &pluginName, T *&pPlugin ) const;

	/** Find and returns the plug-in by name.
	 *  The plug-in is removed from the registered plug-ins.
	 *  The found plug-in is casted in the asked type
	 */
	template <typename T>
	StatusCode takeCastedPlugin( const std::string &pluginName, T *&pPlugin );

	/** Whether the plug-in is registered within the plug-in manager.
	 *  The found plug-in is casted in the asked type
	 */
	template <typename T>
	bool isCastedPluginRegistered( const std::string &pluginName ) const;

	/** Get the plug-in name list
	 */
	StringVector getPluginNameList() const;

private:
	/** Constructor
	 */
	DQMPluginManager();

	/** Destructor
	 */
	~DQMPluginManager();

	/** Register the plug-in. Only available by plug-ins themselves
	 */
	StatusCode registerPlugin( DQMPlugin *pPlugin );

private:

	DQMPluginMap              m_pluginMap;
	mutable bool            m_registerNextPlugin;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

template <typename T>
inline StatusCode DQMPluginManager::getCastedPlugin( const std::string &pluginName, T *&pPlugin ) const
{
	pPlugin = NULL;
	DQMPlugin *pTestPlugin = NULL;

	RETURN_RESULT_IF( STATUS_CODE_SUCCESS, !=, this->getPlugin( pluginName, pTestPlugin ) );

	pPlugin = dynamic_cast< T * >( pTestPlugin );

	if(NULL == pPlugin)
		return STATUS_CODE_FAILURE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

template <typename T>
inline StatusCode DQMPluginManager::getCastedPluginClone( const std::string &pluginName, T *&pPlugin ) const
{
	pPlugin = NULL;
	DQMPlugin *pTestPlugin = NULL;

	RETURN_RESULT_IF( STATUS_CODE_SUCCESS, !=, this->getPlugin( pluginName, pTestPlugin ) );

	m_registerNextPlugin = false;
	pTestPlugin = pTestPlugin->clone();
	m_registerNextPlugin = true;

	pPlugin = dynamic_cast< T * >( pTestPlugin );

	if(NULL == pPlugin)
		return STATUS_CODE_FAILURE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

template <typename T>
inline StatusCode DQMPluginManager::takeCastedPlugin( const std::string &pluginName, T *&pPlugin )
{
	pPlugin = NULL;
	DQMPlugin *pTestPlugin = NULL;

	if( ! isPluginRegistered( pluginName ) )
		return STATUS_CODE_NOT_FOUND;

	DQMPluginMap::iterator findIter = m_pluginMap.find( pluginName );
	pTestPlugin = findIter->second;

	if( NULL == pTestPlugin )
		return STATUS_CODE_FAILURE;

	pPlugin = dynamic_cast< T * >( pTestPlugin );

	if(NULL == pPlugin)
		return STATUS_CODE_FAILURE;

	m_pluginMap.erase( findIter );

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

template <typename T>
inline bool DQMPluginManager::isCastedPluginRegistered( const std::string &pluginName ) const
{
	DQMPluginMap::const_iterator findIter = m_pluginMap.find( pluginName );

	if( findIter == m_pluginMap.end() )
		return false;

	T *pCastedPlugin = dynamic_cast< T * >( findIter->second );

	if( NULL == pCastedPlugin )
		return false;

	return true;
}

} 

#endif  //  DQMPLUGINMANAGER_H
