  /// \file DQMObserver.h
/*
 *
 * DQMObserver.h header template automatically generated by a class generator
 * Creation date : jeu. janv. 28 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMOBSERVER_H
#define DQMOBSERVER_H

#include "dqm4hep/DQM4HEP.h"

namespace dqm4hep
{

/** DQMObserver class.
 *
 *  Interface for an observer pattern. Observers are added to observable
 *  and is updated when the observable notifies any state change
 */
template <typename T>
class DQMObserver 
{
public:
	/** Destructor
	 */
	virtual ~DQMObserver() {}

	/** call back method received when an observable notifies
	 */
	virtual void update(T *pUpdatedObject) = 0;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** DQMObservable class.
 */
template <typename T>
class DQMObservable
{
public:
	/** Destructor
	 */
	virtual ~DQMObservable();

	/** Add an observer to this observable
	 */
	virtual StatusCode addObserver(DQMObserver<T> *pObserver);

	/** Remove an observer from this observable
	 */
	virtual StatusCode removeObserver(DQMObserver<T> *pObserver);

	/** Notify observer of a state change
	 */
	virtual void notify(T *pUpdatedObject);

private:
	std::vector< DQMObserver<T> * >     m_observerList;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

template <typename T>
inline DQMObservable<T>::~DQMObservable()
{
	m_observerList.clear();
}

//-------------------------------------------------------------------------------------------------

template <typename T>
inline StatusCode DQMObservable<T>::addObserver(DQMObserver<T> *pObserver)
{
	if(NULL == pObserver)
		return STATUS_CODE_INVALID_PTR;

	if(std::find(m_observerList.begin(), m_observerList.end(), pObserver) != m_observerList.end())
		  return STATUS_CODE_ALREADY_PRESENT;

	m_observerList.push_back(pObserver);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

template <typename T>
inline StatusCode DQMObservable<T>::removeObserver(DQMObserver<T> *pObserver)
{
	if(NULL == pObserver)
		return STATUS_CODE_INVALID_PTR;

	typename std::vector< DQMObserver<T> * >::iterator findIter = std::find(m_observerList.begin(), m_observerList.end(), pObserver);

	if(findIter == m_observerList.end())
		  return STATUS_CODE_NOT_FOUND;

	m_observerList.erase(findIter);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

template <typename T>
inline void DQMObservable<T>::notify(T *pUpdatedObject)
{
	for(typename std::vector< DQMObserver<T> * >::iterator iter = m_observerList.begin(), endIter = m_observerList.end() ;
			endIter != iter ; ++iter)
		(*iter)->update(pUpdatedObject);
}

} 

#endif  //  DQMOBSERVER_H
