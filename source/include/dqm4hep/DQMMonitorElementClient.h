/*
 *
 * DQMMonitorElementClient.h header template automatically generated by a class generator
 * Creation date : dim. mai 10 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMMONITORELEMENTCLIENT_H
#define DQMMONITORELEMENTCLIENT_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/DQMMessaging.h"
#include "dqm4hep/DQMDataStream.h"

// -- dim headers
#include "dic.hxx"

namespace dqm4hep
{

class DQMMonitorElementClient;

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

class DQMMeCollectorInfoRpcInfo : public DimRpcInfo
{
public:
	DQMMeCollectorInfoRpcInfo(char *rpcInfoName, DQMMonitorElementClient *pClient);
	void rpcInfoHandler();

private:
	DQMMonitorElementClient      *m_pClient;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

class DQMMeListNameRpcInfo : public DimRpcInfo
{
public:
	DQMMeListNameRpcInfo(char *rpcInfoName, DQMMonitorElementClient *pClient);
	void rpcInfoHandler();

private:
	DQMMonitorElementClient      *m_pClient;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** DQMMonitorElementClientListener class.
 *
 *  Listeners receive notifications for each of the callback methods above
 */
class DQMMonitorElementClientListener
{
public:
	/** Destructor
	 */
	virtual ~DQMMonitorElementClientListener() {}

	/** Called back on client connection
	 */
	virtual void onMonitorElementClientConnect(DQMMonitorElementClient */*pClient*/) {}

	/** Called back on client disconnection
	 */
	virtual void onMonitorElementClientDisconnect(DQMMonitorElementClient */*pClient*/) {};

	/** Called back on server connection
	 */
	virtual void onServerStartup(DQMMonitorElementClient */*pClient*/) {}

	/** Called back when the server is shutdown
	 */
	virtual void onServerShutdown(DQMMonitorElementClient */*pClient*/) {}

	/** Called back when available me list is received
	 */
	virtual void availableMonitorElementListReceived(DQMMonitorElementClient */*pClient*/, const DQMMonitorElementInfoList &/*infoList*/) {}

	/** Called back when me collector info is received
	 */
	virtual void monitorElementCollectorInfoReceived(DQMMonitorElementClient */*pClient*/, const DQMCollectorInfo &/*collectorInfo*/) {}

	/** Called back when monitor elements are received.
	 *  WARNING ! The client owns the publication passed in argument.
	 *  After notifying the publication is cleared and monitor elements deleted.
	 *  Since the publication is not constant, the listener can take elements and
	 *  remove them from the publication.
	 */
	virtual void monitorElementsReceived(DQMMonitorElementClient */*pClient*/, DQMMonitorElementPublication &/*publication*/) {}
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** DQMMonitorElementClient class
 */ 
class DQMMonitorElementClient : public DimClient
{
public:
	/** Constructor
	 */
	DQMMonitorElementClient();

	/** Destructor
	 */
	~DQMMonitorElementClient();

	/** Set the collector name. Can be done only if the client is
	 *  not yet connected to collector service
	 */
	StatusCode setCollectorName(const std::string &collectorName);

	/** Get the collector name
	 */
	const std::string &getCollectorName() const;

	/** Connect the client to the service
	 */
	StatusCode connectToService();

	/** Disconnect the client from the service
	 */
	StatusCode disconnectFromService();

	/** Whether the client is connected to the service
	 */
	bool isConnectedToService() const;

	/** Sent a request to the collector to get back the collector informations
	 */
	StatusCode queryCollectorInfo();

	/** Send a request to get back monitor element list name (small packet info)
	 */
	StatusCode queryAvailableMonitorElements(const DQMMonitorElementListNameRequest &request);

	/** Unsubscribe to monitor elements
	 */
	StatusCode subscribe(const DQMMonitorElementRequest &request);

	/** Subscribe to monitor elements
	 */
	StatusCode unsubscribe(const DQMMonitorElementRequest &request);

	/** Unsubscribe to all monitor elements the client has already
	 *  subscribed and subscribe to monitor elements
	 */
	StatusCode replaceSubscription(const DQMMonitorElementRequest &request);

	/** Send a command to query the monitor element list.
	 *  The element in the list are first subscribed.
	 *  Then a query is sent to update only the element in the request
	 */
	StatusCode querySubscribedMonitorElements(const DQMMonitorElementRequest &request);

	/** Send a command to query the monitor element list that the client subscribed
	 */
	StatusCode querySubscribedMonitorElements();

	/** Set the update mode. If set to true, subscribed monitor elements will be received
	 *  when an update is performed on the collector server side
	 */
	void setUpdateMode(bool updateMode);

	/** Get the update mode
	 */
	bool getUpdateMode() const;

	/** Whether the collector is running
	 */
	bool isCollectorRunning() const;

	/** Add a listener to this client (observer pattern).
	 */
	bool addListener(DQMMonitorElementClientListener *pListener);

	/** Remove a listener from this client
	 */
	void removeListener(DQMMonitorElementClientListener *pListener);

public:
	static const std::string         m_emptyBufferStr;

private:
	/** Handle the collector info rpc callback
	 */
	void handleMeCollectorInfoRpcInfo(DimRpcInfo *pRpcInfo);

	/** Handle the me name list rpc callback
	 */
	void handleMeListNameRpcInfo(DimRpcInfo *pRpcInfo);

	/** Dim info handler
	 */
	void infoHandler();

	/** Deep clear of publication
	 */
	void clearPublication(DQMMonitorElementPublication &publication);

private:
	DimRpcInfo                            *m_pMeCollectorInfoRpcInfo;
	DimRpcInfo                            *m_pMeListNameRpcInfo;
	DimUpdatedInfo                        *m_pMeUpdateInfo;
	DimInfo                               *m_pCollectorStateInfo;

	DQMDataStream                          m_inDataStream;  // to receive data
	DQMDataStream                          m_outDataStream; // to send data

	std::string                            m_collectorName;
	bool                                   m_isConnected;
	bool                                   m_updateMode;
	bool                                   m_isCollectorRunning;

	// listeners
	std::vector<DQMMonitorElementClientListener *>    m_listeners;

	friend class DQMMeCollectorInfoRpcInfo;
	friend class DQMMeListNameRpcInfo;
};

} 

#endif  //  DQMMONITORELEMENTCLIENT_H
