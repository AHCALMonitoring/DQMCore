  /// \file DQMAlertSystem.h
/*
 *
 * DQMAlertSystem.h header template automatically generated by a class generator
 * Creation date : mar. mars 22 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMALERTSYSTEM_H
#define DQMALERTSYSTEM_H

#include "xdrstream/xdrstream.h"

#include "dqm4hep/DQM4HEP.h"

#include "dis.hxx"
#include "dic.hxx"

#include <memory>

namespace dqm4hep
{

enum DQMAlertType
{
	SOFTWARE_ALERT,
	DANGER_ALERT,
	BIOHAZRD_ALERT,
	LEAK_ALERT,
	DAQ_ALERT,
	OTHER_ALERT
};

/** DQMAlertSystem class
 */
class DQMAlert : public xdrstream::Streamable
{
public:
	/** Constructor
	 */
	DQMAlert();

	/** Constructor with alert attributes
	 */
	DQMAlert(const std::string &emitter, DQMAlertType type,
			const std::string &message = "", const DQMMonitorElementPtr &monitorElement = DQMMonitorElementPtr());

	/** Destructor
	 */
	~DQMAlert();

	/** Get the alert emitter name
	 */
	const std::string &getEmitter() const;

	/** Get alert type
	 */
	DQMAlertType getType() const;

	/** Set the alert type
	 */
	void setType(DQMAlertType type);

	/** Set the alert message
	 */
	void setMessage(const std::string &message);

	/** Get the alert message
	 */
	const std::string &getMessage() const;

	/** Get the monitor element associated to the alert.
	 *  May be NULL.
	 */
	const DQMMonitorElementPtr &getMonitorElement() const;

	/** Set the monitor element associated to the alert (not mandatory)
	 */
	void setMonitorElement(const DQMMonitorElementPtr &monitorElement);

	xdrstream::Status stream(xdrstream::StreamingMode mode, xdrstream::IODevice *pDevice,
			xdrstream::xdr_version_t version = 0);

private:
	std::string                    m_emitter;
	DQMAlertType                   m_type;
	std::string                    m_message;
	DQMMonitorElementPtr           m_monitorElement;
};

typedef std::shared_ptr<DQMAlert> DQMAlertPtr;

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** DQMAlertNotifier class
 */
class DQMAlertNotifier
{
public:
	/** Constructor with emitter name
	 */
	DQMAlertNotifier(const std::string &emitter);

	/**
	 */
	virtual ~DQMAlertNotifier();

	/**
	 */
	const std::string &getEmitter() const;

	/**
	 */
	StatusCode notify(DQMAlertType type, const std::string &message, const DQMMonitorElementPtr &monitorElement = DQMMonitorElementPtr() );

	/**
	 */
	void setMinAlertInterval(int nSeconds);

public:
	/**
	 */
	virtual StatusCode startService() = 0;

	/**
	 */
	virtual StatusCode stopService() = 0;

	/**
	 */
	virtual bool isRunning() const = 0;

protected:
	/** Send alert notification to clients
	 */
	virtual StatusCode notify(const std::string &emitter, DQMAlertType type,
			const std::string &message, const DQMMonitorElementPtr &monitorElement = DQMMonitorElementPtr() ) = 0;

private:
	std::string                      m_emitter;
	int                              m_minAlertInterval;
	time_t                           m_lastNotificationTime;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** DQMDimAlertNotifier class
 */
class DQMDimAlertNotifier : public DQMAlertNotifier
{
public:
	/** Constructor with emitter name
	 */
	DQMDimAlertNotifier(const std::string &emitter);

	/**
	 */
	~DQMDimAlertNotifier();

	/**
	 */
	StatusCode startService();

	/**
	 */
	StatusCode stopService();

	/**
	 */
	bool isRunning() const;

protected:
	StatusCode notify(const std::string &emitter, DQMAlertType type, const std::string &message, const DQMMonitorElementPtr &monitorElement = DQMMonitorElementPtr() );

private:
	DimService                    *m_pNotificationService;
	bool                           m_isRunning;
	xdrstream::BufferDevice       *m_pBuffer;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** DQMAlertListener class
 */
class DQMAlertListener
{
public:
	/** Destructor
	 */
	virtual ~DQMAlertListener();

	/** Call back method on alert reception
	 */
	virtual void onAlert(DQMAlertPtr alert) = 0;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/**
 */
class DQMAlertHandler
{
public:
	/**
	 */
	virtual ~DQMAlertHandler();

	/**
	 */
	void addListener(DQMAlertListener *pListener);

	/**
	 */
	void removeListener(DQMAlertListener *pListener);

	/**
	 */
	virtual StatusCode connectToService() = 0;

	/**
	 */
	virtual StatusCode disconnectFromService() = 0;

	/**
	 */
	virtual bool isConnected() const = 0;

protected:
	/**
	 */
	void notifyListeners(DQMAlertPtr alert);

private:
	std::set<DQMAlertListener *>              m_listeners;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/**
 */
class DQMDimAlertHandler : public DQMAlertHandler, public DimClient
{
public:
	/**
	 */
	DQMDimAlertHandler(const std::string &emitter);

	/**
	 */
	~DQMDimAlertHandler();

	/**
	 */
	const std::string &getEmitter() const;

	StatusCode connectToService();
	StatusCode disconnectFromService();
	bool isConnected() const;

private:
	/**
	 */
	void configureInBuffer(char *pBuffer, xdrstream::xdr_size_t bufferSize);

	void infoHandler();

private:
	bool                                     m_isConnected;
	std::string                              m_emitter;
	DimUpdatedInfo                          *m_pAlertInfo;
	xdrstream::BufferDevice                 *m_pBuffer;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/**
 */
class DQMDimAlertInterface : public DQMAlertHandler, public DimClient, public DimTimer
{
public:
	/**
	 */
	DQMDimAlertInterface();

	/**
	 */
	virtual ~DQMDimAlertInterface();

	/**
	 */
	virtual void newEmitterRegistered(const std::string &emitter);

	/**
	 */
	virtual void emitterUnregistered(const std::string &emitter);

	/**
	 */
	void setUpdateTime(int updateTime);

	/**
	 */
	StatusCode connectToService();

	/**
	 */
	StatusCode disconnectFromService();

	/**
	 */
	bool isConnected() const;

private:
	void infoHandler();
	void timerHandler();

	/**
	 */
	StringVector browse();

	/**
	 */
	void configureInBuffer(char *pBuffer, xdrstream::xdr_size_t bufferSize);

private:
	typedef std::map<std::string, DimInfo *> EmitterInfoMap;

	EmitterInfoMap                           m_emitterInfoMap;
	xdrstream::BufferDevice                 *m_pBuffer;
	int                                      m_updateTime;
	bool                                     m_isConnected;
};

// TODO Add documentation
// TODO implement DQMModuleApi alert methods + Module application

}

#endif  //  DQMALERTSYSTEM_H
