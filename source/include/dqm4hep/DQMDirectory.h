  /// \file DQMDirectory.h
/*
 *
 * DQMDirectory.h header template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMDIRECTORY_H
#define DQMDIRECTORY_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/DQMPath.h"

namespace dqm4hep
{

class DQMMonitorElement;

/** DQMDirectory class.
 *
 *  A directory is the owner of its sub-directories.
 *  Monitor elements owning depends on how the method
 *  are called (default : not owner)
 *
 *  This interface doesn't allow moving sub-directories
 */
class DQMDirectory
{
public:
	/** Default constructor
	 */
	DQMDirectory();

	/** Constructor with name and parent dir
	 */
	DQMDirectory(const std::string &name, DQMDirectory *pParentDir = NULL);

	/** Destructor.
	 *  Delete the subdirectories but not the contents
	 */
	~DQMDirectory();

	/** Create a new directory
	 */
	StatusCode mkdir(const std::string &dirName);

	/** List the directory contents and subdirs if asked
	 */
	void ls(bool recursive = false) const;

	/** Returns the directory name
	 */
	const std::string &getName() const;

	/** Returns the parent directory
	 */
	DQMDirectory *getParentDir() const;

	/** Get the sub directory list
	 */
	const std::vector<DQMDirectory*> &getSubDirList() const;

	/** Whether the directory contains the sub dir
	 */
	bool containsDir(const std::string &dirName) const;

	/** Find the sub directory by name
	 */
	StatusCode findDir(const std::string &dirName, DQMDirectory *&pDirectory) const;

	/** Add a monitor elements to the directory
	 */
	StatusCode addMonitorElement(DQMMonitorElement *pMonitorElement);

	/** Find a monitor element with a given name in the directory
	 */
	StatusCode findMonitorElement(const std::string &name, DQMMonitorElement *&pMonitorElement) const;

	/** Whether the directory contains the monitor element (search by ptr compare)
	 */
	bool containsMonitorElement(const DQMMonitorElement *pMonitorElement) const;

	/** Whether the directory contains the monitor element (search by name compare)
	 */
	bool containsMonitorElement(const std::string &monitorElementName) const;

	/** Remove the monitor element from the directory
	 */
	StatusCode removeMonitorElement(DQMMonitorElement *pMonitorElement);

	/** Remove the monitor element from the directory
	 */
	StatusCode removeMonitorElement(const std::string &monitorElementName);

	/** Get the monitor element list
	 */
	const std::vector<DQMMonitorElement*> &getMonitorElementList() const;

	/** Remove the directory and its contents
	 *  Delete monitor element if deepClean set to true
	 */
	StatusCode removeDir(const std::string &dirName, bool deepClean = false);

	/** Clear the directory by calling delete on each
	 *  sub-dirs and clear the monitor element list by calling delete if asked.
	 *  The operation is done recursively
	 */
	StatusCode clear(bool deepClean = false);

	/** Get the full path name of the directory
	 */
	DQMPath getFullPathName() const;

	/** Whether the directory is a root directory
	 */
	bool isRootDir() const;

	/** Whether the directory is empty
	 */
	bool isEmpty() const;

private:

	/** Recursive print of sub directory structure (dirs and contents)
	 */
	void ls(int depth) const;

	// members
	std::string                        m_name;
	DQMDirectory                      *m_pParentDir;
	std::vector<DQMDirectory*>         m_directoryList;
	std::vector<DQMMonitorElement*>    m_contentsList;
};

} 

#endif  //  DQMDIRECTORY_H
